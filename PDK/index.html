<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Notlar</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="49825236-111b-4205-92c1-713d6b7f6b88" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">ğŸ—’ï¸</span></div><h1 class="page-title">Notlar</h1></header><div class="page-body"><h3 id="c7c96550-1d7e-4c2f-b9fb-05b1b5de1cc7" class="">Neden Programlama Dillerinin KavramlarÄ± Dersi?</h3><pre id="2e451c2a-8ef5-429f-a50f-a5435b7bc357" class="code"><code>- Fikirlerimizi uygularken daha kolay ve daha iyi
	yapabilmek iÃ§in.
â€“ Programalama dillerinin detaylarÄ±nÄ± bilerek yazÄ±lÄ±m
	zenginleÅŸtirilebilir.
- SeÃ§eneklerimizin ne olduÄŸunu bilirsek iyiyi seÃ§ebiliriz.
â€“ Bilgimizi artÄ±rarak eldeki probleme en uygun
	programlama dilini seÃ§ebiliriz.
- Dil Ã¶ÄŸrenmede yetkinlik. Dillerin Ã¶zelliklerini bilmeyen,
	belli bir dille Ã§alÄ±ÅŸmaya alÄ±ÅŸmÄ±ÅŸ kiÅŸi, farklÄ± bir dili
	Ã¶ÄŸrenmesi gerektiÄŸinde zorlanÄ±r.
â€“ Ã–rnek: Nesneye yonelik programlama kavramÄ±nÄ± bilen bir
	kiÅŸi, Javaâ€™yÄ± bu konsepti bilmeyen bir kiÅŸiye gore daha kolay
	Ã¶ÄŸrenebilir.
- Belli bir dilin Ã¶nemli Ã¶zelliklerini anlayarak daha iyi
	kullanabilmek iÃ§in.
â€“ Diller komplex yapÄ±lardan olusur. Fakat Ã¶nemli Ã¶zellikler etkin
	kullanÄ±larak yazÄ±lÄ±m gelistirilebilir.
- Dilleri daha iyi deÄŸerlendirebilirsek, doÄŸru seÃ§imler yaparÄ±z,
	doÄŸru teknolojilerin geliÅŸmesine destek olmuÅŸ oluruz.
- GerÃ§ekleÅŸtirimin anlaÅŸÄ±lmasÄ±yla programlama dilini daha iyi
	anlama.
â€“ Ã–rnek: Alt programlar(fonksiyonlar) sÄ±klÄ±kla Ã§aÄŸrÄ±lÄ±rsa, program hÄ±zÄ± duÅŸer.
	Bunu bilirsek daha iyi program tasarÄ±mÄ± yapabiliriz.
- Hata bulurken Ã¶zelliklerini bilmemiz faydalÄ±dÄ±r.
- Ã–zellikleri Ã¶ÄŸreniriz, olmayan Ã¶zelliklerine Ã¶ykÃ¼nÃ¼rÃ¼z.</code></pre><h3 id="9544de1d-00af-4be1-8ad4-778268de66a4" class="">Structured (YapÄ±sal) &amp; Unstructured (YapÄ±sal olmayan) Diller</h3><pre id="07ef9db3-bf09-46d7-95b9-4d0fadbbbfdd" class="code"><code>Structured languages: Alt programlar(fonksiyonlar), bloklar, koÅŸul ifadeleri, modÃ¼ller,
dÃ¶ngÃ¼ ifadeleri kullanÄ±lan programlama tipidir. Ã‡oÄŸu programlama dili buna Ã¶rnektir.

Unstructured languages: Tek blokta yazÄ±lan, baÅŸka blok kullanÄ±lmayan, programlama dili
tipidir. Ã–rneÄŸin assembly, Basic, COBOL, Fortran
</code></pre><figure id="4688c028-e116-4aa3-9f52-3896ed3de007" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/str.png"><img style="width:720px" src="Notlar%204688c028e1164aa39f523896ed3de007/str.png"/></a></figure><h3 id="907df0b5-8804-4a12-b84a-765f67a4b5e8" class="">Procedural Languages &amp; non-Procedural Languages</h3><pre id="f45b712a-a49a-4105-81e7-fb640092ee2c" class="code"><code>Procedural languages: AlÄ±ÅŸageldiÄŸimiz, adÄ±m adÄ±m problem Ã§Ã¶zdÃ¼ÄŸÃ¼mÃ¼z programlama
tekniÄŸidir. Ã–rneÄŸin C&#x27;deki main fonksiyonu iÃ§inde yazdÄ±ÄŸÄ±mÄ±z kodlarÄ± dÃ¼ÅŸÃ¼nebiliriz.
Bu kodlar satÄ±r satÄ±r, bir algoritmaya dayalÄ± olarak yazÄ±ldÄ±. Herhangi bir fonksiyon ya da 
sÄ±nÄ±f(class(zaten C&#x27;de yok :D)) kullanÄ±lmadÄ±. DÃ¼mdÃ¼z yazÄ±ldÄ±. Hah iÅŸte biz buna
procedural programming diyoruz. Evet yazmasÄ± zordur ama hÄ±zlÄ± ve etkilidir.
Ã–rneÄŸin; C, COBOL, Assembly

Non-procedural languages: AdÄ±m adÄ±m problem Ã§Ã¶zmek yerine problemin nasÄ±l Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼yle
deÄŸil cevabÄ±yla ilgilenen programlama tekniÄŸidir. Ã–rneÄŸin bÃ¼tÃ¼n problemlerinizi
fonksiyonlar iÃ§inde yazarsanÄ±z ve ana fonskiyonunuz iÃ§inde bu fonksiyonlarÄ± Ã§aÄŸÄ±racak
ÅŸekilde bir yapÄ± kurarsanÄ±z istediÄŸiniz yeri, ilgili fonksiyonu silmekle kaldÄ±rabilirsiniz.
Ã–rneÄŸin; SQL, Visual Basic</code></pre><figure id="3891a95a-10dd-40a6-aad4-7563941a9565" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/pro.png"><img style="width:939px" src="Notlar%204688c028e1164aa39f523896ed3de007/pro.png"/></a></figure><h3 id="bab96af4-38e1-4f6d-bcfc-9510fcff6f4c" class="">Scripting Languages &amp; Programming Languages</h3><pre id="c8d1e599-bdc1-46be-8af5-84200db12b49" class="code"><code>AslÄ±nda script dilleri de programlama dilidir.

Script dilleri yorumlanan dillerdir.

Ancak script dillerinin farkÄ± herhangi bir compile aÅŸamasÄ± geÃ§irmemeleridir.

C, C++ gibi diller derlemeye ihtiyaÃ§ duyarken
Javascript(aslÄ±nda ihtiyaÃ§ duyar. Ã‡Ã¼nkÃ¼ JIT kullanÄ±r), PHP dilleri derlemeye ihtiyaÃ§
duymaz.

PHP, Javascript, Python, VBScript dilleri derlenmez ve script dillerdir

C, C++ dilleri ise derlenir.</code></pre><h3 id="a605857c-e0c0-4fbf-9912-ef611cefb8d8" class="">Programlama Dillerinin Temel DeÄŸerlendirme Kriterleri</h3><pre id="8070f066-3f83-42fc-805e-a29e114e2a43" class="code"><code>Okunabilirlik
YazÄ±labilirlik
GÃ¼venilirlik
Maliyet</code></pre><p id="e16b0fa1-e6b7-47bb-b7d7-446dad5934c6" class=""><em><strong>Okunabilirlik</strong></em></p><pre id="eb1adfb6-b872-49bc-a060-70192da1d16f" class="code"><code>Ã–zellik Ã‡okluÄŸu(feature multiplicity): Bir iÅŸin birden Ã§ok ÅŸekilde yapÄ±labilmesi.
Ã–rneÄŸin C&#x27;de bir deÄŸiÅŸkeni bir artÄ±rmak 4 ÅŸekilde yapÄ±labilir:
count = count + 1
count += 1
count++
++count

Ã–zellik Ã§okluÄŸu abartÄ±lmamalÄ±dÄ±r.

Operator Overloading: Bir operatÃ¶rÃ¼n birden fazla iÅŸ yapmasÄ±
Ã–rneÄŸin; &quot;*&quot; iÅŸareti hem pointer sembolÃ¼ olarak kullanÄ±rken hem de Ã§arpma operatÃ¶rÃ¼dÃ¼r.
Bu da abartÄ±lmamalÄ±dÄ±r.

Her zamanki gibi her ÅŸeyin fazlasÄ± zarar :) Bunlar okunabilirliÄŸi kÃ¶tÃ¼ etkiliyor.
Kodu okuyan kiÅŸi bir sÃ¼reliÄŸine &quot;*&quot;in hangi amaÃ§la kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamakta zorlanabilir

Bir programlama dilinde veri tip ve veri yapÄ±larÄ± tanÄ±mlamadaki esneklik,
okunabilirliÄŸe katkÄ± saÄŸlamaktadÄ±r.
Ã–rnek: Timeout=1 vs Timeout=true

Kendi kendini tanÄ±tan yapÄ±lar olmasÄ± okunabilirliÄŸi pozitif yÃ¶nde etkiler.
Ã–rneÄŸin; bir string&#x27;i baÅŸka bir veri tipine Ã§evirmek iÃ§in kullanÄ±lan metotlarÄ±n
isimlerinin anlamlÄ± olmasÄ±. Metodu bilmesek bile isminden ne iÅŸ yaptÄ±ÄŸÄ±nÄ± anlayabiliyoruz
Ã–rnek: parseInt(myString)</code></pre><p id="d29e2efe-046a-4c3b-a4d4-ee21e5db430c" class=""><em><strong>YazÄ±labilirlik</strong></em></p><pre id="6ce671e5-3602-4df4-a9c6-274dd869e7d0" class="code"><code>Bir dilin; seÃ§ilen bir problem bazÄ±nda programlar oluÅŸturmak iÃ§in
ne kadar kolay kullanÄ±labileceÄŸinin bir Ã¶lÃ§Ã¼tÃ¼dÃ¼r.

Ortogonalite: Daha az ilkel yapÄ± ve bunlarÄ± birleÅŸtirmek iÃ§in tutarlÄ± bir kurallar
							dizisidir.

Ã–rneÄŸin bir dilde temel yapÄ±lar kullanmak iÃ§in dizilerin yerine ilkel veri
tiplerinden(int, float, char) dizi yapmaya Ã§alÄ±ÅŸmak fazla ortoganallik iÃ§in
okunabilirliÄŸi(ayrÄ±ca yazÄ±labilirliÄŸi ve maliyeti de) doÄŸrudan etkiler.

Ortogonalitenin diÄŸer bir tanÄ±mÄ±; kullanÄ±cÄ±nÄ±n yapabileceÄŸi kombinasyon sayÄ±sÄ±nÄ±
optimumda tutmaktÄ±r.

&quot;Fonksiyonlar dizi dÃ¶ndÃ¼rmez&quot; durumu bir istisnadÄ±r. Bu da ortogonalliÄŸe terstir.
Ä°stisna arttÄ±kÃ§a kullanÄ±cÄ±nÄ±n bilmesi gereken durum sayÄ±sÄ± artacaÄŸÄ±ndan kombinasyon
sayÄ±sÄ± artar ve karmaÅŸÄ±klÄ±k artar. Ã–ÄŸrenmeyi ve dile hakimiyeti zorlaÅŸtÄ±rÄ±r.

Ortogonalitenin diÄŸer bir tanÄ±mÄ±; baÄŸlamdan baÄŸÄ±msÄ±z kod yazmaktÄ±r.
Ã–rneÄŸin farklÄ± parametre olarak int ya da float alabilecek tek bir fonksiyon yazmak
yerine int ve float parametreli iki ayrÄ± fonksiyon yazmak ortogonaliteyi dÃ¼ÅŸÃ¼rÃ¼r.
-----------------------------------------------------------------------------------

YazÄ±labilirlik; okunabilirlikten doÄŸrudan etkilenir.

Belirli bir problem ya da alanda iki dilde de uygulamasÄ± yapÄ±lmadÄ±ÄŸÄ± sÃ¼rece
iki dilin yazÄ±labilirliÄŸini karÅŸÄ±laÅŸtÄ±rabilmek Ã§ok makul deÄŸildir.
&quot;Bu dil bu dilden daha yazÄ±labilirdir&quot; cÃ¼mlesi pek doÄŸru deÄŸildir yani.

Ortogonalitenin dÃ¼ÅŸÃ¼k olmasÄ± yani kullanÄ±cÄ±nÄ±n(programcÄ±nÄ±n) bilmesi gereken
ihtimallerin Ã§okluÄŸu yazÄ±labilirliÄŸi kÃ¶tÃ¼ etkiler.

Bu nedenle, daha az sayÄ±da ilkel yapÄ± ve bunlarÄ±
birleÅŸtirmek iÃ§in tutarlÄ± bir kurallar dizisi (yani,
ortogonalite), Ã§ok sayÄ±da temel maddeye sahip olmaktan
Ã§ok daha iyidir.

Soyutlama(Abstraction) desteÄŸi: KarmaÅŸÄ±k yapÄ±larÄ± ve iÅŸlemleri, ayrÄ±ntÄ±larÄ± gÃ¶z ardÄ±
ederek kullanabilme yeteneÄŸi
Process(iÅŸlem) soyutlama: Mesela fonksiyonlar. Zaten yazÄ±lmÄ±ÅŸ olan bir fonksiyonu
kullanmak isteyen birisi fonksiyonun iÃ§inde ne dÃ¶ndÃ¼ÄŸÃ¼nÃ¼ bilmek zorunda deÄŸildir.
(varsa) Gerekli parametreleri verir ve sonucunu alÄ±r. BÃ¶ylece iÅŸlemden soyutlanmÄ±ÅŸ olur.

Data(veri) soyutlama: GerÃ§ek hayattaki bir nesneyi / canlÄ±yÄ± gerekli Ã¶zellikleriyle
bilgisayar ortamÄ±na aktarmamÄ±zÄ± saÄŸlar</code></pre><h3 id="395b6a2a-d3f5-466f-984d-da3e376ce48b" class=""><em><strong>GÃ¼venilirlik</strong></em></h3><pre id="06bbeef0-d31f-4007-9711-6287b52fd691" class="code"><code>Bir program tÃ¼m ÅŸartlar altÄ±nda gÃ¶revini baÅŸarÄ±yla yerine getirebiliyorsa gÃ¼venlirdir.

Bir program veri tipi kontrolÃ¼nÃ¼ iyi yapmalÄ±dÄ±r. Aksi takdirde kullanÄ±cÄ±nÄ±n yanlÄ±ÅŸ bir yere
yanlÄ±ÅŸ bir veri tipi girmesi uygulamada hatalara neden olabilir.

Gayet normal olduÄŸu Ã¼zere uygulamada hatalarla karÅŸÄ±laÅŸÄ±rÄ±z. Ancak bu hatalarÄ±n kullanÄ±cÄ±ya
en saf haliyle yansÄ±tÄ±lmasÄ±nÄ± istemeyiz. HiÃ§bir kullanÄ±cÄ± ekranÄ±nda &quot;NullPointerException&quot;
diye bir hata gÃ¶rmek istemez ve anlamaz da zaten. Bu tÃ¼r olaÄŸan hatalara karÅŸÄ± kullanÄ±cÄ±ya
hata fÄ±rlatÄ±lmasÄ± ve bu hatalarÄ±n Ã¶z ve aÃ§Ä±klayÄ±cÄ± olmasÄ± gerekir.

AynÄ± bellek bÃ¶lgesini gÃ¶steren birden fazla pointer olmasÄ± gÃ¼venilir deÄŸildir. Tehlikeli
bir Ã¶zelliktir Ã§Ã¼nkÃ¼ biri deÄŸiÅŸtiÄŸinde diÄŸeri de deÄŸiÅŸir. KÄ±sÄ±tlanmalÄ±dÄ±r.</code></pre><p id="8c4133bc-d7db-434e-bcb8-f5f7fcc19ddf" class=""><em><strong>Maliyet</strong></em></p><pre id="8f19db2f-1319-48a8-8412-d1e5617fa989" class="code"><code>Ã‡alÄ±ÅŸanlarÄ±n eÄŸitim sÃ¼reci

(varsa) derleyici Ã¼creti (paralÄ± derleyiciler var. UygulamayÄ± satarken
derleyicinin de satÄ±lmasÄ± gerekir.)

UygulamayÄ± yazma sÃ¼recindeki gelir-giderler

ProgramlarÄ±n bakÄ±mÄ±

Optimizasyon Ã¼creti

GÃ¼venilirlik (sistem gÃ¼venliÄŸi iÃ§in bÃ¼tÃ§e)</code></pre><figure id="bf0d17ca-2938-40b6-abf0-38e35e2c04ad" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/as.png"><img style="width:861px" src="Notlar%204688c028e1164aa39f523896ed3de007/as.png"/></a></figure><h3 id="b4f040f9-cfc9-4693-93a7-86e3fab2d17f" class="">TaÅŸÄ±nabilirlik Nedir? (Temel olmasa da bu da deÄŸerlendirme kriterlerindendir)</h3><p id="a697bb49-f560-4680-ad62-a00e33c917a7" class=""><strong><mark class="highlight-blue">Hedef programlama dilinde yazÄ±lan kodun herhangi bir platforma ya da ortama baÄŸÄ±mlÄ± kalmamasÄ±dÄ±r. Bir yazÄ±lÄ±m oluÅŸturulmak istendiÄŸinde Linux iÃ§in ayrÄ±, Windows iÃ§in ayrÄ±, macOS iÃ§in ayrÄ± kod yazÄ±lmasÄ± Ã§ok ÅŸey kaybettirir. Ä°stenen ÅŸey bir tane kod ile bÃ¼tÃ¼n platformlara Ã§Ä±ktÄ± verebilmesidir. Ä°ÅŸte taÅŸÄ±nabilirlik de tam olarak bunu saÄŸlar. Ã–rneÄŸin C dili taÅŸÄ±nabilir bir deÄŸildir. Her platform iÃ§in ayrÄ± kodlar yazmak gerekir. Ancak Ã¶rneÄŸin Java, Python taÅŸÄ±nabilir dillerdir. Tek kodla bÃ¼tÃ¼n platformlara Ã§Ä±ktÄ± verilebilir. AyrÄ±ca yorumlanan diller zaten taÅŸÄ±nabilir Ã¶zelliÄŸe sahiptir. Java hibrit bir sisteme sahip olmasÄ±na raÄŸmen kendi Java VM(virtual machine) sayesinde taÅŸÄ±nabilirlik Ã¶zelliÄŸine sahip olmaktadÄ±r.</mark></strong></p><h2 id="a0fbe372-a1b5-49dc-8d77-d0b616c80e7e" class="">Bilgisayar Mimarisi Etkisi</h2><pre id="63a5fd28-817d-48d5-91b4-008d8686093f" class="code"><code>Von Neumann bilgisayarlarÄ± nedeniyle zorunlu diller (imperative
languages) (C, C++, Java, COBOL) yaygÄ±ndÄ±r

â€“ Veri ve programlar aynÄ± bellekte saklanÄ±r
â€“ Bellek, CPUâ€™dan ayrÄ±dÄ±r
â€“ Komutlar ve veri bellekten CPUâ€™ya iletilir(pipeline)
â€“ Zorunlu (imperative) dillerin temelleri
â€¢ DeÄŸiÅŸkenler(variables) bellek hÃ¼crelerini modeller
â€¢ Atama ifadeleri(Assignment statements) iletimi(piping) modeller
â€¢ TekrarlamayÄ± gerÃ§ekleÅŸtirme iÃ§in yinelemeli tekrarlama (iteration) etkili
â€¢ Iterasyon, von Neumann bilgisayarlarÄ±nda hÄ±zlÄ±</code></pre><h3 id="5b49ca34-e6d3-4336-8f64-57a58496bba0" class="">Dil Kategorileri</h3><pre id="bc5139bc-02fd-4ae1-a6f2-e7c5d04b456b" class="code"><code>â€¢ Emirsel/Zorunlu(imperative)
	â€“ Merkezi Ã¶zellikleri deÄŸiÅŸkenler, atama ifadeleri ve dÃ¶ngÃ¼lerdir
	â€“ Ã–rnek: C, Pascal
â€¢ Fonksiyonal(Functional)
	â€“ Hesaplama yapmanÄ±n temelinde veriler ve parametreli fonksiyonlarÄ± uygulamak
	â€“ Ã–rnek: LISP, Scheme
â€¢ MantÄ±k(Logic)
	â€“ Kural tabanlÄ± (kurallar belirli sÄ±ralama olmadan verilir)
	â€“ Ã–rnek: Prolog
â€¢ Nesneye yÃ¶nelik (Object-oriented)
	â€“ Veri soyutlama, kalÄ±tÄ±m, polymorphism
	â€“ Ã–rnek: Java, C++
â€¢ Ä°ÅŸaretleme (Markup)
	â€“ Yeni; tam bir programlama dili deÄŸillerdir fakat (tek gÃ¶revleri bu olmasa da)web
		dÃ¶kÃ¼manlarÄ±ndaki bilginin yerleÅŸimini belirtmede kullanÄ±lÄ±r.
	â€“ Ã–rnek: XHTML, XML</code></pre><h3 id="56d673f1-7f61-4f86-b7ca-b42c8800ae20" class="">Nesne yÃ¶nelimli bir programlama dilinin Ã¼Ã§ temel Ã¶zelliÄŸi nelerdir?</h3><p id="1a8ed571-17d5-4910-8627-60a6a990bf05" class=""><mark class="highlight-orange"><strong>Abstraction(soyutlama): GerÃ§ek hayattaki bir nesneyi / canlÄ±yÄ± gerekli Ã¶zellikleriyle bilgisayar ortamÄ±na aktarmamÄ±zÄ± saÄŸlar. GerÃ§ek hayatÄ± modelleyebiliriz. Bu yÃ¼zden nesne yÃ¶nelimli programlama gÃ¼nlÃ¼k hayattaki problemlerimizi Ã§Ã¶zmede oldukÃ§a Ã¶nemlidir.</strong></mark></p><p id="2c5a32c2-53a6-4c7a-b986-a11aa72722e1" class=""><mark class="highlight-orange"><strong>Poliformizm: Ã‡ok biÃ§imlilik olarak Ã§evrilse de bu tanÄ±m kÄ±sÄ±r kalmaktadÄ±r. Java Ã¼zerinden gidecek olursak; Java&#x27;da miras alÄ±nan sÄ±nÄ±fÄ±n metotlarÄ±nÄ± aynÄ± isimle tekrardan miras alan sÄ±nÄ±f iÃ§inde yazabiliriz. Ve bir sÄ±nÄ±fÄ±n iÃ§indeki metodu aynÄ± isimle, farklÄ± parametreler yazabiliriz. Yani bir tek metot varken bu metotlarÄ±n farklÄ± formlarÄ±nÄ± yazmÄ±ÅŸ olduk.</strong></mark></p><p id="e78c2900-29a6-4a82-8512-934ffe2c6677" class=""><mark class="highlight-orange"><strong>Polimorfizm&#x27;in farklÄ± bir tanÄ±mÄ± olarak; bir sÄ±nÄ±ftan miras alan birden Ã§ok sÄ±nÄ±f, miras alÄ±nan nesnenin tipinde oluÅŸturulabilir. Ã–rneÄŸin kedi, kÃ¶pek ve at nesnelerimiz olsun ve bu nesneler bir &#x27;Hayvan&#x27; sÄ±nÄ±fÄ±ndan miras alsÄ±n. Kedi, kÃ¶pek, at hayvanlarÄ±nÄ±n bir instance&#x27;Ä± oluÅŸturulurken hepsini, atasÄ± olan Hayvan sÄ±nÄ±fÄ± tipinde oluÅŸturabiliriz. Bu da polimofizm&#x27;e Ã¶rnektir.</strong></mark></p><p id="3d612dcd-235f-4823-bfa8-45328fa7f1e5" class=""><mark class="highlight-orange"><strong>Inheritance: Bir sÄ±nÄ±fÄ±n, baÅŸka bir sÄ±nÄ±fÄ±n Ã¶zelliklerini almasÄ±dÄ±r. Elimizde hayvan ve at sÄ±nÄ±flarÄ±mÄ±z olsun. At da bir hayvan olduÄŸu iÃ§in atÄ±n sahip olduÄŸu birÃ§ok Ã¶zellik hayvanda da vardÄ±r. Bu yÃ¼zden at, hayvan sÄ±nÄ±fÄ±ndan miras alÄ±r. Onun sahip olduÄŸu Ã¶zelliklere sahip olur ve kendisininmiÅŸ gibi kullanÄ±r. Poliformizm&#x27;de de bahsediliÄŸi Ã¼zere at sÄ±nÄ±fÄ± hayvan sÄ±nÄ±fÄ±nÄ±n Ã¶zelliklerini override edebilir.</strong></mark></p><figure id="a30f393d-9de0-4a49-9c6e-e74dfb174374" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/trade.png"><img style="width:909px" src="Notlar%204688c028e1164aa39f523896ed3de007/trade.png"/></a></figure><h3 id="11afe6f3-182f-4efb-b565-47149564386d" class="">Getiri - GÃ¶tÃ¼rÃ¼ Ä°liÅŸkileri</h3><pre id="1d03e29c-d5d8-4e51-b4a3-23fa0c7ee831" class="code"><code>â€¢ GÃ¼venilirliÄŸe karÅŸÄ± Ã§alÄ±ÅŸtÄ±rma maliyeti
	â€“ Ã–rneÄŸin: Java dizi iÃ§indeki elemanlarÄ±n tamamÄ±na
		ulaÅŸÄ±mda referanslarÄ±n ve indislerin kontrol edilmesini
		talep eder, bu da Ã§alÄ±ÅŸtÄ±rma maliyetini arttÄ±rÄ±r.

â€¢ OkunabilirliÄŸe karÅŸÄ± yazÄ±labilirlik
	â€“ Ã–rneÄŸin: APL(bir dil) birÃ§ok gÃ¼Ã§lÃ¼ operatÃ¶r yardÄ±mÄ±yla oldukÃ§a
		karmaÅŸÄ±k hesaplamalarÄ±n yapÄ±labilmesine imkan verir
		fakat okunabilirlik azalÄ±r.
â€¢ YazÄ±labilirliÄŸe (esneklik)karÅŸÄ± gÃ¼venilirlik
	â€“ Ã–rneÄŸin: C++ iÅŸaretÃ§ileri gÃ¼Ã§lÃ¼dÃ¼r ve oldukÃ§a esnektir
		fakat kullanÄ±mÄ± gÃ¼venilir deÄŸildir.</code></pre><h3 id="679d184b-22fa-428a-aba0-db30feffbefa" class=""><mark class="highlight-purple_background">GerÃ§ekleÅŸtirim MetotlarÄ± (Ã‡OK Ã–NEMLÄ°!!!)</mark></h3><p id="79a85955-f61c-4d86-9e5c-238b0d447ca5" class="">1- <strong>Derleme</strong>: YazÄ±lan kodlarÄ± makine diline Ã§evirir. Bu Ã§eviri sÃ¼reci tamamlandÄ±ktan sonra diÄŸer gerÃ§ekleÅŸtirim metotlarÄ±na gÃ¶re daha hÄ±zlÄ±dÄ±r. Ã‡Ã¼nkÃ¼ bu Ã§eviri iÅŸlemi sadece bir kez yapÄ±lmaktadÄ±r. Uygulama her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda bu Ã§evrilen kod sadece Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.</p><p id="f218d748-d01a-493b-9a81-5b2d366d1422" class="">Derleyicinin kendi iÃ§inde birkaÃ§ aÅŸamasÄ± vardÄ±r:  </p><ol type="1" id="40aa0209-f4ff-413d-9c10-a5c3fc2f17f5" class="numbered-list" start="1"><li>Ä°lk olarak dili ifadelere/dilin kÃ¶klerine ayÄ±rÄ±r(lexical analyze)</li></ol><ol type="1" id="14e91769-3fa5-4bf3-9921-c1ebc3700fee" class="numbered-list" start="2"><li>AyrÄ±lan ifadelerde yazÄ±m olarak bir hata olup olmadÄ±ÄŸÄ±nÄ± kontrol eder(syntax analyze)</li></ol><ol type="1" id="e40c07f9-891e-45c7-b082-b8dfa866e6fd" class="numbered-list" start="3"><li>Ä°fadelerin mantÄ±ksal aÃ§Ä±dan uygun olup olmadÄ±ÄŸÄ±nÄ± kontrol eder. Ã–rneÄŸin tiplerin uygun olup olmadÄ±ÄŸÄ±, deÄŸiÅŸkenlerin kullanÄ±mdan Ã¶nce tanÄ±mlanÄ±p tanÄ±mlanmadÄ±ÄŸÄ±...(semantic analyze)</li></ol><ol type="1" id="326925d3-96b9-4fbf-8288-515b22420291" class="numbered-list" start="4"><li>Ara kod Ã¼retir. Ara kod; program, makine diline Ã§evrilmeden Ã¶nce oluÅŸturulan bir koddur. Ara kodun amacÄ±, daha az kodla daha fazla cihazda Ã§alÄ±ÅŸmaktÄ±r. Her compiler&#x27;in her cihazÄ± tanÄ±masÄ± gerekir ara kod olmazsa. Ancak Ã§evrilen ara kod hep aynÄ± formatta olduÄŸu iÃ§in cihazlar ara kodu tanÄ±maktadÄ±r.</li></ol><p id="0098067e-2bf1-458f-8f9d-b08773d35fd3" class="">2- <strong>Saf yorumlama</strong>: YazÄ±lan kodun satÄ±r satÄ±r okunmasÄ± ve Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±dÄ±r. Derleme iÅŸlemindeki gibi ara sÃ¼reÃ§ler barÄ±ndÄ±rmaz. Hata ayÄ±klama, derlemeye gÃ¶re daha kolaydÄ±r. Ã‡Ã¼nkÃ¼ derleyici, kodun tamamÄ±nÄ± derledikten sonra bÃ¼tÃ¼n hatalarÄ± gÃ¶sterir. Ancak yorumlayÄ±cÄ±, ilk hata gÃ¶rdÃ¼ÄŸÃ¼ satÄ±rda hata verir dÃ¼zeltilmesini ister. EÄŸer derleme sÃ¼reci ve Ã§alÄ±ÅŸtÄ±rÄ±lma sÃ¼reci beraber deÄŸerlendirilirse yorumlayÄ±cÄ± derleyiciden hÄ±zlÄ±dÄ±r. Ancak derleyici kodu bir kez derledikten sonra Ã§alÄ±ÅŸtÄ±rÄ±lma hÄ±zlarÄ± karÅŸÄ±laÅŸtÄ±rÄ±lÄ±rsa derleyici onlarca kat daha hÄ±zlÄ±dÄ±r. </p><p id="cd88e383-186a-4cf5-898d-869ed8453202" class="">SatÄ±r satÄ±r iÅŸleme esnasÄ±nda karÅŸÄ±laÅŸÄ±lan her ifade ve fonksiyon yeniden yorumlanÄ±r. Ancak derleyici kodun tamamÄ±nÄ± deÄŸerlendikten sonra Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in fonksiyon artÄ±k derlenmiÅŸ ve Ã§alÄ±ÅŸmaya hazÄ±rdÄ±r.</p><p id="acccdd31-851d-4725-af09-e86c4ec1b4d1" class="">Ama yorumlayÄ±cÄ±, her gÃ¶rdÃ¼ÄŸÃ¼ fonksiyon ve ifadeye, ilk kez gÃ¶rmÃ¼ÅŸ gibi muamele etmekte ve yeniden deÄŸerlendirmektedir. Bu da bir darboÄŸaza(performans yetmezliÄŸi) yol aÃ§maktadÄ±r. Bu, derleyiciye gÃ¶re elbette bÃ¼yÃ¼k bir performans ve hÄ±z kaybÄ±dÄ±r.</p><figure id="6cf24ff0-50cd-41ef-a537-539b7b2747de" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/interp.png"><img style="width:672px" src="Notlar%204688c028e1164aa39f523896ed3de007/interp.png"/></a></figure><p id="d6aff448-97cc-462b-8f6d-6765d3435d88" class="">3- <strong>Hibrit sistemler</strong>: Hem derleyici hem yorumlayÄ±cÄ±dan oluÅŸan sistemlerdir. Her ikisinin iyi yÃ¶nlerini alÄ±p daha iyisini oluÅŸturmaya Ã§alÄ±ÅŸmÄ±ÅŸtÄ±r. YorumlayÄ±cÄ±nÄ±n geliÅŸtirme kolaylÄ±ÄŸÄ± ve hata ayÄ±klamasÄ±nÄ± alÄ±p, derleyicinin ise hÄ±zÄ±nÄ± almaktadÄ±r.</p><p id="4749cd02-e1d8-4ae0-b908-f5401e5ad863" class="">Derleyicide olduÄŸu gibi kodu derleme sÃ¼recinden geÃ§irip ara kodu oluÅŸturur ve oluÅŸturulan ara kodu yorumlar. </p><pre id="609ae29c-7c76-4e4d-a913-cd0261ffa62e" class="code"><code>JIT(Just in Time) Compiler: Bir hibrit sistemdir. Kodda Ã§aÄŸrÄ±lmayan fonksiyonlarÄ± dahil
etmeden bir kez derler. Derleme bittikten sonra Ã§alÄ±ÅŸÄ±rken yorumlama yapar.
Bir fonksiyon Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda o fonksiyonu derler, ardÄ±ndan Ã§aÄŸÄ±rÄ±r ve yoluna devam eder.
Ã–rneÄŸin JAVA</code></pre><p id="c74445b4-1fd8-46d5-b6d9-4c0f64514989" class="">4- <strong>Ã–niÅŸlemciler: </strong>Program derlenmeden Ã¶nce baÅŸka bir programÄ± iÅŸlerler.</p><pre id="9d09f862-79f6-4dcf-a772-e0ceeaab5687" class="code"><code>Ã–niÅŸlemciler genellikle baÅŸka bir dosyadaki kodun belirtilmesi iÃ§in
kullanÄ±lÄ±r
â€“ Ã–rneÄŸin, &quot;myLib.h&quot; adlÄ± C Ã¶n iÅŸlemcisi yÃ¶nergesi, Ã¶niÅŸlemcinin
myLib.h&#x27;nin iÃ§eriÄŸini #include konumuna kopyalamasÄ±na neden olur.

Program derlenmeden Ã¶nce dahil edilen bu dosyaya eklenir.</code></pre><pre id="584c3a63-190e-40ac-9f33-d2be04fdf28d" class="code"><code>Mutlak Adresleme: Ã–rneÄŸin Assembly dilinde komutlar art arda yazÄ±lÄ±r. Ve her komut RAM&#x27;de
oturur ve bir adres alÄ±r. Daha sonra kodda aradan silinen bir satÄ±r bÃ¼tÃ¼n adreslerin
bozulmasÄ±na yol aÃ§ar. Ve aynÄ± ÅŸekilde araya eklenen bir satÄ±r yine adreslerin
kaymasÄ±na yol aÃ§ar. Bunu Ã§Ã¶zmek iÃ§in silinen satÄ±rÄ±n yerini boÅŸ bÄ±rakÄ±yoruz ki diÄŸer
adreslerde kayma yaÅŸanmasÄ±n.</code></pre><pre id="9c7b5f51-1161-4004-9ed3-fe2fe0b81384" class="code"><code>Von Neumann DarboÄŸazÄ±

â€¢ BilgisayarÄ±n belleÄŸi ile iÅŸlemcisi arasÄ±ndaki baÄŸlantÄ± hÄ±zÄ± bilgisayarÄ±n hÄ±zÄ±nÄ± belirler

â€¢ Program talimatlarÄ± genellikle baÄŸlantÄ± hÄ±zÄ±ndan daha hÄ±zlÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rlar; bÃ¶ylece
	baÄŸlantÄ± hÄ±zÄ± darboÄŸaz oluÅŸturur.

â€¢ Bu von Neumann darboÄŸazÄ± olarak bilinir; bu bilgisayarlarÄ±n hÄ±zÄ±nÄ± sÄ±nÄ±rlandÄ±ran
	birincil etkendir.</code></pre><h3 id="92d3a720-2851-4f7d-b15a-5f47ee3c009b" class="">Sembol tablosu derleyicide nasÄ±l bir rol oynar?</h3><p id="147c0876-56a7-4efe-b690-32f64d955db8" class="">Sembol tablosu; derleyici iÃ§in bir veritabanÄ±dÄ±r diyebiliriz. DeÄŸiÅŸkenlerin, sabitlerin, sÄ±nÄ±flarÄ±n, fonksiyonlarÄ±n... isimleri ve bilgileri tutulur. Ã–rneÄŸin bir deÄŸiÅŸkenin deÄŸeri deÄŸiÅŸtiÄŸinde sembol tablosunda da o deÄŸiÅŸkenin deÄŸeri ve bilgileri deÄŸiÅŸir.</p><p id="fe3bbc7f-a00c-4655-871a-772a2fa3e4da" class="">Derleyicinin aÅŸamalarÄ± iÃ§in sembol tablosu olmazsa olmazÄ±dÄ±r. ÅÃ¶yle ki:</p><p id="76d0197c-b4e2-4179-9505-39904c1f74af" class="">Lexical analyzer aÅŸamasÄ±nda sembol tablosu oluÅŸturulur ve token giriÅŸleri yapÄ±lÄ±r.</p><p id="3dc45ed1-f62f-4bb5-9bb9-e3456666d310" class="">EÄŸer syntax(sÃ¶zdizimi) doÄŸru ise sembol tablosuna token ile ilgili bilgiler yazÄ±lÄ±r. KapsamÄ±(scope), boyutu, tipi(class, function....)...</p><p id="b9067d92-c9e1-43a2-9c6f-7b52b4b9ec1b" class="">Anlamsal olarak doÄŸruluÄŸunu kontrol etmek iÃ§in(semantic analyzer) her iÅŸlemde sembol tablosuna gidip yapÄ±lan iÅŸlemin verilere gÃ¶re tutarlÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.</p><hr id="7ca860ec-98da-4080-ad17-5f3559cd1a2f"/><p id="6593a20f-0f5a-44c2-89f3-ec38d57a5b67" class="">
</p><pre id="5fbc2238-fd8c-4e38-bb98-f4f4a169603c" class="code"><code>Lexeme: Dildeki en kÃ¼Ã§Ã¼k anlamlÄ± ifadedir. SÃ¶zcÃ¼k gibidir.
Ã–rneÄŸin; sum, begin, if, var...

Token ise lexeme gruplarÄ±dÄ±r. Bir lexeme&#x27;nin birden fazla grubu olabilir.
Ã–rneÄŸin; identifier, operator, keywords...
Token tÃ¼rleri dilden dile deÄŸiÅŸebilir.
Ã–rneÄŸin &quot;*&quot; iÅŸareti de bir lexeme&#x27;dir. Bu iÅŸaret Ã§arpma iÅŸleminde kullanÄ±ldÄ±ÄŸÄ± gibi
pointer iÅŸareti olarak da kullanÄ±ldÄ±ÄŸÄ± iÃ§in bu lexeme&#x27;nin birden fazla tokeni vardÄ±r.</code></pre><pre id="a193e094-5496-449c-8bd5-35761f237307" class="code"><code>Dil tanÄ±yÄ±cÄ±larÄ±(recognizers): Verilen bir ifadenin dile ait olup olmadÄ±ÄŸÄ±na karar verir.
SÃ¶zdizimini(syntax) analiz eder.
Finite State Automatas (FSA) and Push Down Automatas (PDAs) iyi bilinen
tanÄ±yÄ±cÄ± Ã¶rnekleridir.

Ancak derste bunla pek ilgilenmiyoruz.

Dil Ã¼reticileri(generators): AdÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± Ã¼zere dil cÃ¼mleleri oluÅŸturmak
iÃ§in kullanÄ±lan bir aygÄ±ttÄ±r.

Context-free Grammars(CFG) ve Regular Expressions(DÃ¼zenli Ä°fadeler) iyi bilinen
generator Ã¶rnekleridir.

TanÄ±yÄ±cÄ±lar ve Ã¼reticiler arasÄ±ndaki fark:
CÃ¼meleler dilin kurallarÄ±na uygun mu diye kontrol etmek iÃ§in tanÄ±yÄ±cÄ±lar,
grammar ile cÃ¼mle eÅŸleÅŸiyor mu diye bakarken; Ã¼reticiler mevcut grammar&#x27;dan cÃ¼mleler
Ã¼retip bu cÃ¼mlelerden herhangi biriyle eÅŸleÅŸiyor mu diye bakar.</code></pre><pre id="ffeae4aa-e788-472d-913a-13f6405977d7" class="code"><code>Dilbilgisi (grammar), programlama dillerinin sÃ¶zdizimini tanÄ±mlamak iÃ§in
yaygÄ±n olarak kullanÄ±lan resmi dil oluÅŸturma mekanizmalarÄ±</code></pre><pre id="1daccc44-4a45-4f8f-8f0b-6b6303fbb8a3" class="code"><code>Chomsky(dil bilimci), Context-free gÃ¶sterimini buluyor.</code></pre><pre id="8b2adb3d-ba5c-430c-8b8b-dc2f75f948f0" class="code"><code>TÃ¼m programlama dilleri(kÃ¼Ã§Ã¼k istisnalar hariÃ§) Context-free&#x27;dir.</code></pre><pre id="e1e6bb25-463e-4c9b-a6c0-d95c58403752" class="code"><code>ALGOL58&#x27;in tanÄ±mlanmasÄ± iÃ§in Backus tarafÄ±ndan yeni bir gÃ¶sterim tanÄ±tÄ±ldÄ±.
Naur amca ise bu gÃ¶sterimi geliÅŸtirerek, ALGOL 60&#x27;Ä±n tanÄ±mlanmasÄ± iÃ§in bu forma yeni halini verdi.
Bu form artÄ±k BNF(Backus Naur Form) olarak anÄ±lmaktadÄ±r.</code></pre><pre id="51cbad65-66ae-4a09-a915-b2f8a95bd736" class="code"><code>BNF neredeyse CFG ile aynÄ±dÄ±r.</code></pre><h3 id="4a015904-59f1-4f77-b1c6-11cdf95f9fd2" class="">BNF</h3><pre id="530e9c00-06fb-4f5e-8945-865ff71d1e69" class="code"><code>BNF; programlama dilleri iÃ§in metadildir.</code></pre><pre id="39d76912-e3bf-4e87-85ab-691ab66aba86" class="code"><code>BNF, syntax iÃ§in soyutlama ifadeleri kullanÄ±lÄ±r. Bu soyutlama ifadeleri, kÃ¼Ã§Ã¼ktÃ¼r-bÃ¼yÃ¼ktÃ¼r
karakterleri arasÄ±nda gÃ¶sterilir. Soyutlama ifadelerine non-terminal sembol adÄ± verilir.
Dilin kurallarÄ±, anahtar kelimeleri, operatÃ¶rleri, sabitleri(string, sayÄ±...) ise
terminal sembol olarak adlandÄ±rÄ±lÄ±r.

&lt;assign&gt; -&gt; &lt;var&gt; = &lt;expression&gt;
// Ok iÅŸaretinin sol tarafÄ±na, Left Hand Side(LHS); saÄŸ tarafÄ±na Right Hand Side(RHS) denir</code></pre><pre id="ad3319fc-da5f-4e40-9b18-8dc7f5ebe629" class="code"><code>BNF basit olmasÄ±na raÄŸmen oldukÃ§a gÃ¼Ã§lÃ¼dÃ¼r ve Ã§oÄŸu(ileride eksiklerini gÃ¶receÄŸiz) problemi Ã§Ã¶zer.</code></pre><pre id="4887349f-3780-4b42-88fa-690b3399ff61" class="code"><code>BNF ile neler gÃ¶sterilebilir?

- Benzer yapÄ±larÄ±n listelerini,
â€“ FarklÄ± yapÄ±larÄ±n gÃ¶rÃ¼nme sÄ±rasÄ±nÄ±,
â€“ Herhangi bir derinliÄŸe yuvalanmÄ±ÅŸ yapÄ±larÄ± tanÄ±mlayabilir
â€“ Hatta operatÃ¶rÃ¼n Ã¶nceliÄŸini ve operatÃ¶rÃ¼n birleÅŸimini ima edebilir</code></pre><pre id="06624ba7-a6ce-4fdf-9ffc-3e69be2e91c2" class="code"><code>BNF&#x27;te Recursion(Yineleme)

Bir kural(non-terminal), LHS&#x27;nin kendi RHS&#x27;sinde gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ takdirde tekrarlayÄ±cÄ±dÄ±r.

&lt;ident_list&gt; -&gt; &lt;identifier&gt; | &lt;identifier&gt;; &lt;ident_list&gt;</code></pre><pre id="c334fba9-f7a4-4991-b38a-a2c37197a3e8" class="code"><code>Tam bir programlama dili iÃ§in bir dilbilgisinde, baÅŸlangÄ±Ã§ sembolÃ¼ tam bir programÄ±
temsil eder ve genellikle &lt;program&gt; olarak adlandÄ±rÄ±lÄ±r.</code></pre><pre id="b4e0b113-a171-4611-a206-82e4709944fa" class="code"><code>&lt;program&gt; dahil olmak Ã¼zere, tÃ¼retmedeki satÄ±rlarÄ±n her birine
bir cÃ¼mle (sentatial) formu denir</code></pre><figure id="0af717dd-4498-4577-affe-6beb1275c7b3" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/lhs.png"><img style="width:720px" src="Notlar%204688c028e1164aa39f523896ed3de007/lhs.png"/></a></figure><pre id="98e94cb1-92dd-4ce7-827f-e4f52d0a6f3a" class="code"><code>YukarÄ±daki gibi, ifade soldan aÃ§Ä±lmaya baÅŸlanmÄ±ÅŸtÄ±r. Yani non-terminal semboller soldan
baÅŸlayarak aÃ§Ä±la aÃ§Ä±la gerÃ§ek ifadelere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸtÃ¼r. Her adÄ±mda en soldaki
non-terminal yok edilmeye Ã§alÄ±ÅŸÄ±lÄ±r. Buna Left Hand Derivation yani soldan tÃ¼retme
adÄ± verilir.
EÄŸer non-terminaller saÄŸdan baÅŸlayarak(her zaman en saÄŸdaki yok edilseydi) tÃ¼retilseydi
buna Right Hand Derivation yani saÄŸdan tÃ¼retme denirdi.

TÃ¼retmenin saÄŸdan veya soldan olmasÄ±nÄ±n dil Ã¼zerinde bir etkisi yoktur.
Ä°kisinde de aynÄ± sonuÃ§ Ã§Ä±kacaktÄ±r(eÄŸer belirsiz deÄŸilse(bu ileride gÃ¶rÃ¼lecek))</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="2be05f98-f354-4874-8946-f9f81d1e50ac"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">SÄ±navda her adÄ±mda(satÄ±rda) sadece bir tane non-terminal deÄŸiÅŸikliÄŸi(tÃ¼retmesi) yap. Yoksa GG ğŸ˜‰</div></figure><pre id="2868c30b-5111-4722-afa9-83fffc4b4fef" class="code"><code>TÃ¼retme, hiÃ§bir non-terminal kalmayana kadar devam eder. BÃ¼tÃ¼n non-terminaller
terminal ifadelere Ã§evirilir.</code></pre><h3 id="9e381210-6434-477b-ad21-7a926f8da719" class="">Parse Trees (AyrÄ±ÅŸtÄ±rma AÄŸaÃ§larÄ±)</h3><pre id="dc99c31e-23db-4c79-99d8-524cc7da7b19" class="code"><code>BNF gÃ¶sterimindeki ifadelerin(dilin cÃ¼mlelerinin) bir aÄŸaÃ§ yardÄ±mÄ±yla gÃ¶sterilmesidir.</code></pre><h3 id="114c8c0d-973e-4178-ac68-01935108c2e5" class="">Belirsizlik</h3><pre id="f1996b2c-6977-4940-890a-fd0cbb08cfb7" class="code"><code>Bir cÃ¼mle formu iÃ§in iki veya daha fazla ayrÄ± ayrÄ±ÅŸtÄ±rma aÄŸacÄ±nÄ±n bulunduÄŸu
dilbilgisi belirsizdir.

EÄŸer saÄŸdan tÃ¼retme ve soldan tÃ¼retmede farklÄ± sonuÃ§lar Ã§Ä±kÄ±yorsa bu cÃ¼mle formu
belirsizdir.

EÄŸer soldan tÃ¼retmede birden fazla; saÄŸdan tÃ¼retmede birden fazla aÄŸaÃ§ bulunuyorsa
bu cÃ¼mle belirsizdir.

Bir gramerin belirsiz olup olmadÄ±ÄŸÄ±nÄ± anlamak matematiksel olarak imkansÄ±zdÄ±r

BazÄ± ayrÄ±ÅŸtÄ±rma algoritmalarÄ± belirsiz gramerlere dayanabilir.
BÃ¶yle bir gramerle karÅŸÄ±laÅŸÄ±ldÄ±ÄŸÄ±nda, tasarÄ±mcÄ± uygun olan grameri tercih eder.</code></pre><h3 id="77dca85e-bc3a-4bc1-aa46-7e7eea3cd432" class="">OperatÃ¶r Ã–nceliÄŸi</h3><pre id="4fb56c60-101a-4b6c-9d1f-e64daba0f152" class="code"><code>AyrÄ±ÅŸtÄ±rma aÄŸacÄ±nda en aÅŸaÄŸÄ±da bulunan(en fazla derinliÄŸe sahip olan) operatÃ¶r
en Ã¶nceliklidir.</code></pre><h3 id="458a1b38-ea91-4b24-ab32-6b98b0ab5dd6" class="">OperatÃ¶rlerin BirleÅŸmesi</h3><pre id="504f4dc7-996f-4ab4-90fb-6d705dc112f6" class="code"><code>AynÄ± Ã¶nceliÄŸe sahip operatÃ¶rlerin birleÅŸme sÄ±rasÄ± nasÄ±l olacak?
3+5+2-7
Bu ifadedeki operatÃ¶rlerin Ã¶ncelikleri aynÄ±. Peki ilk olarak hangi iÅŸlem yapÄ±lacak?
Prefix, postfix, infix ÅŸekilde yapabiliriz. Yani sÄ±rasÄ±yla; soldan, saÄŸdan ya da ortadan
baÅŸlayabiliriz.

EÄŸer soldan birleÅŸtirmeye kalkarsak buna Left Associativity; saÄŸdan birleÅŸtirmeye
kalkarsak buna right associativity denir.

EÄŸer elimizdeki oluÅŸturduÄŸumuz grameri postfix, infix ve prefix ÅŸekilde aÃ§maya kalktÄ±ÄŸÄ±mÄ±zda
farklÄ± sonuÃ§lar elde ediyorsak bu cÃ¼mle belirsizdir.</code></pre><pre id="f2fe7727-ae6b-4c8c-ac9e-d8d664375222" class="code"><code>EÄŸer bir LHS, kendisinin RHS&#x27;sinin sol tarafÄ±nda da gÃ¶zÃ¼kÃ¼yorsa buna left recursion;
bir LHS, kendisinin RHS&#x27;sinin saÄŸ tarafÄ±nda da gÃ¶zÃ¼kÃ¼yorsa buna right recursion denir.
Ã–rneÄŸin;
&lt;exp&gt; -&gt; &lt;exp&gt; + &lt;term&gt; =&gt; Left recursion
&lt;exp&gt; -&gt; &lt;term&gt; + &lt;exp&gt; =&gt; right recursion</code></pre><pre id="bcb4b435-cd6e-4d3f-bb09-d9454013f3bf" class="code"><code>Ã‡oÄŸu dilde, Ã¼s alma operatÃ¶rÃ¼ right recursion ile yapÄ±lÄ±r. Right Associativity&#x27;i gÃ¶stermek
iÃ§in right recursion kullanÄ±lmÄ±ÅŸ oldu.</code></pre><h3 id="0aaf83bb-c3cc-439e-9bd5-98cde6d58a63" class="">BNF - EBNF</h3><pre id="315cb7ec-524d-43e5-ab17-2bdb792ec6b0" class="code"><code>EBNF, Extended(geniÅŸletilmiÅŸ) BNF anlamÄ±na gelmektedir.

EBNF&#x27;nin BNF&#x27;den gÃ¼Ã§ olarak bir farkÄ± yoktur.

Hatta dÃ¶ngÃ¼leri gÃ¶rÃ¼ntÃ¼lemede sÄ±kÄ±ntÄ±lÄ±dÄ±r.

EBNF, BNF&#x27;in okunurluÄŸunu ve yazÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r.</code></pre><pre id="15650cbe-900c-4b0a-bbf9-885cd4d7663e" class="code"><code>EBNF&#x27;teki 

- [] â†’ isteÄŸe baÄŸlÄ± nonterminal: Ä°Ã§ine yazÄ±lan sembol, gelmek zorunda deÄŸildir,
				isteÄŸe baÄŸlÄ±dÄ±r.
		Ã–r: &lt;switch&gt; -&gt; switch &lt;case&gt;: &lt;stmt&gt;[;default: &lt;stmt&gt;]

- (), â†’ birden fazla seÃ§enek olabilir. (+ | - | *) gibi
		Ã–r: &lt;expr&gt; -&gt; &lt;var&gt; (+ | - | * | /) &lt;var&gt;

- {} â†’  iterasyon iÃ§in: iÃ§ine girilen non-terminal birden Ã§ok kez yazÄ±labilir, recursion
					oluÅŸur.
		Ã–r: &lt;ident_list&gt; -&gt; &lt;identifier&gt; {,&lt;identifier&gt;}

 iÅŸaretleri metasembollerdir.</code></pre><hr id="9940d899-08d8-4684-9850-843ad3fb0bf7"/><h3 id="259168c5-b19f-4967-9227-f11fd221115b" class="">Ã–zellik Gramerleri ve Statik Semantik</h3><p id="de8ea23e-94a1-47f9-869d-cb16117a0471" class="">Context free ve BNF, serbest iÃ§erik gramerlerine girmektedir.</p><p id="ba44ca7c-5912-4590-b5e9-32ca1b8b0052" class="">Serbest iÃ§erik gramerleri her ÅŸeyi(tÃ¼m syntax) tanÄ±mlayamazlar:</p><ul id="6ea77995-1b7d-44c4-83d8-b1f33bbf8966" class="bulleted-list"><li style="list-style-type:disc">Variable Initialization&#x27;Ä±(deÄŸiÅŸkene baÅŸta bir deÄŸer atayÄ±p atamama) BNF ile gÃ¶stermek imkansÄ±zdÄ±r.</li></ul><ul id="be52dc8b-4bcb-4bb8-b12f-040ba400a168" class="bulleted-list"><li style="list-style-type:disc">Tip tanÄ±mlamalarÄ± Ã§ok zordur(bunu verimli olarak yapmak iÃ§in analizcinin boyutunu bÃ¼yÃ¼tÃ¼r)</li></ul><p id="6f98d90c-c78b-4899-b199-30c1dd2d7e1b" class="">Bu tip problemler static semantic ile Ã§Ã¶zÃ¼lÃ¼r. Semantic olmasÄ±na raÄŸmen daha Ã§ok syntax ile ilgilidir.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1baf3ed5-b7bf-428e-b7bf-d56b9d693edd"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">Ã–zellik gramerleri, gramerin statik semantik kurallarÄ±nÄ± ve bu kurallarÄ±n doÄŸruluÄŸunu gÃ¶stermek iÃ§in kullanÄ±lan bir yaklaÅŸÄ±m.</div></figure><p id="aaccb399-ed98-4a0b-9a49-9e3e5f3a0826" class="">Derleyici tasarÄ±mlarÄ±nda kullanÄ±lmazlar, resmi deÄŸillerdir ancak kabul gÃ¶rmÃ¼ÅŸlerdir.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7d67995f-c3ec-4f71-acd6-037e93572c43"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">Ã–zelliklerin kontrolÃ¼ compile time&#x27;da olacaÄŸÄ± iÃ§in adÄ± statik semantik</div></figure><p id="306d4f61-9362-44ab-b60a-ba32e3ae58f4" class="">Ã–zellik Gramerleri, Ã¶zellikler, Ã¶zellik hesaplama fonksiyonlarÄ± ve Ã¶nbiÃ§imleme fonksiyonlarÄ± eklenmiÅŸ bir CFG(context-free grammar)&#x27;dir.</p><pre id="07db81fb-5f1e-4b1a-9573-aa2394ba160f" class="code"><code>BNF&#x27;teki non-terminal ve terminaller iÃ§in Ã¶zellikler eklenmiÅŸtir.

Terminal ve non-terminallerin yanÄ±na eklenenlere Ã¶zellik denir.
Mesela; string, actual_type, expected_type,.., deÄŸiÅŸkenlerin yanÄ±na yazÄ±lan
dÃ¼ÄŸÃ¼m(node) sayÄ±larÄ±([3], [2])...

Ä°ki Ã¶zelliÄŸi karÅŸÄ±laÅŸtÄ±rÄ±p geriye true false dÃ¶ndÃ¼ren fonksiyonlara da
predicate functions (Ã¶nbiÃ§imleme fonksiyonlarÄ±) denir. Mesela:
&lt;expr&gt;.expected_type == &lt;var&gt;.actual_type
// &lt;var&gt;&#x27;Ä±n gerÃ§ek tipi ile &lt;expr&gt;&#x27;nin beklenen tipi eÅŸitse true dÃ¶ner.
Predicate fonksiyondan false dÃ¶nmesi sÃ¶z diziminin ihlal edildiÄŸini gÃ¶sterir.

Hesaplama yapÄ±p, geriye sonuÃ§ dÃ¶ndÃ¼ren fonksiyonlar da Attribute computation(semantic)
functions (Ã¶zellik hesaplama fonksiyonlarÄ±) dÄ±r. Mesela, look-up fonksiyonu

look-up fonksiyonu: Sembol tablosundan deÄŸiÅŸkenin deÄŸerini getirir.</code></pre><pre id="39e19aa1-5ef1-4415-a05d-da3e287d3bac" class="code"><code>YapÄ±sal Ã¶zellikler (Intrinsic attributes), deÄŸerleri ayrÄ±ÅŸtÄ±rma aÄŸacÄ±nÄ±n dÄ±ÅŸÄ±nda
belirlenen yaprak dÃ¼ÄŸÃ¼mlerden sentezlenen Ã¶zellikleridir. (TanÄ±mÄ± boÅŸverin)
Yaprak dÃ¼ÄŸÃ¼mler herhangi bir yerden sentezlenemediÄŸi iÃ§in instrinsic Ã¶zellikleri bulunur

Ã–rneÄŸin, bir programdaki deÄŸiÅŸken Ã¶rneÄŸinin tÃ¼rÃ¼, deÄŸiÅŸken
adlarÄ±nÄ± ve tÃ¼rlerini depolamak iÃ§in kullanÄ±lan sembol tablosundan
gelebilir.
&lt;expr&gt;.expected_type &lt;- &lt;var&gt;.actual_type
// Evet, &lt;expr&gt; beklenen tipini &lt;var&gt;&#x27;Ä±n gerÃ§ek tipinden alacak. Peki &lt;var&gt;, tipinin
ne olduÄŸunu nereden biliyor? Ä°ÅŸte bu da intrinsic attribute oluyor. Bunun cevabÄ± aÄŸaÃ§ta
yok. Look-up fonksiyonu yardÄ±mÄ±yla gidip sembol tablosundan &lt;var&gt;&#x27;Ä±n tipini getiriyor.</code></pre><pre id="9289a313-790f-4978-abc4-df48aaa64072" class="code"><code>SentezlenmiÅŸ Ã¶zellik: AÄŸaÃ§ta, child&#x27;larÄ±n Ã¶zelliklerinin sonucunun parent&#x27;e aktarÄ±lmasÄ±
KalÄ±tÄ±m alÄ±nmÄ±ÅŸ Ã¶zellik: Parent&#x27;in Ã¶zelliÄŸinin Ã§ocuklara aktarÄ±lmasÄ±</code></pre><pre id="95be29b9-cc27-4dc4-9337-c5aa42c20ac5" class="code"><code>Ã–zellik Gramerleri Kurallar

DeÄŸiÅŸkenler int ya da real olmalÄ±.
SaÄŸ taraftaki deÄŸiÅŸkenlerin tipi aynÄ± olmak zorunda deÄŸil(eÅŸittir&#x27;in saÄŸ tarafÄ±)

SaÄŸ taraftakilerin tÃ¼rÃ¼ aynÄ± deÄŸilse tÃ¼r her zaman real olur Ã§Ã¼nkÃ¼
bellekte kapladÄ±ÄŸÄ± boyutu fazla 

Her iki tarafÄ±n da tÃ¼rÃ¼ aynÄ± olmalÄ±dÄ±r.</code></pre><pre id="7e191490-eec9-4f74-95b5-68198022ceab" class="code"><code>Syntax kuralÄ±: &lt;var&gt; â†’ A | B | C
Semantik kuralÄ±: &lt;var&gt;.actual_type â† look-up(&lt;var&gt;.string)
// Semantic kuralÄ±, Attribute computation function&#x27;dur.
// lookup fonksiyonu &lt;var&gt;&#x27;Ä±n tipini bulup &lt;var&gt;.actual_type olarak geri dÃ¶ndÃ¼rÃ¼r.
// look-up fonksiyonu parametre olarak deÄŸiÅŸkeni alÄ±r ve deÄŸiÅŸkeni string bir ÅŸekilde
// parametre olarak aldÄ±ÄŸÄ± iÃ§in &quot;.string&quot; yazÄ±lÄ±r. Evet .string de bir Ã¶zelliktir.</code></pre><pre id="d5e020ab-61c9-4781-a7ea-204306bab8a1" class="code"><code>Statik anlam kurallarÄ±nÄ±n kontrolÃ¼ derleyicinin Ã¶nemli bir gÃ¶revidir.</code></pre><pre id="7a873e5e-a994-48f7-9f1e-e74d2408ea3c" class="code"><code>Ã–zellik Gramerleri Eksiklikler

Ã–zellik gramerleri, modern bir programlama dilini tanÄ±mlamak iÃ§in zordur.
Ã–zellik gramerleri Ã§ok bÃ¼yÃ¼k ve karmaÅŸÄ±k kaÃ§Ä±yor.
Modern PD&#x27;nin Ã¶zelliklerini Ã§ok sayÄ±da olmasÄ±, Ã¶zellik gramerlerinde yazma ve okumayÄ±
zorlaÅŸtÄ±rÄ±r.
AyrÄ±ÅŸtÄ±rma aÄŸaÃ§larÄ±nda Ã¶zellikleri deÄŸerlendirme maliyeti</code></pre><h3 id="ac089708-40f7-4c48-ae64-db5e2e34d570" class="">Dinamik Semantikler</h3><pre id="b28031f8-2f6a-4892-93c5-ecf7773570e4" class="code"><code>SÃ¶zdizimi
tanÄ±mÄ± yapmak hem doÄŸal hem de de gÃ¼Ã§lÃ¼ olan evrensel gÃ¶sterim biÃ§imi
nedeniyle anlamsallÄ±ÄŸa gÃ¶re daha kolay bir iÅŸtir. Dinamik anlamsallÄ±ÄŸÄ±
tanÄ±mlamak iÃ§in geliÅŸtirilmiÅŸ evrensel bir gÃ¶sterim biÃ§imi veya yaklaÅŸÄ±m
bulunmamaktadÄ±r.</code></pre><pre id="65d1b2fa-5b16-4da9-b7b6-0ea0cea34074" class="code"><code>AnlamsallÄ±ÄŸÄ± tanÄ±mlamak iÃ§in bir yÃ¶ntem veya gÃ¶sterim biÃ§imine olan ihtiyacÄ±n
birÃ§ok farklÄ± nedeni vardÄ±r. YazÄ±lÄ±mcÄ±lar, programlarÄ±nda kullanmadan Ã¶nce, bir
komutun tam olarak ne iÅŸ yaptÄ±ÄŸÄ±nÄ± bilmek zorundadÄ±r. Derleyici geliÅŸtiriciler ise
doÄŸru tasarÄ±m iÃ§in dilin hangi yapÄ±larÄ±nÄ±n ne anlama geldiÄŸini bilmelidirler. EÄŸer
bir dilin anlamsallÄ±ÄŸÄ± iÃ§in kesin bir tanÄ±mlama bulunsaydÄ±, o dilde yazÄ±lan
programlarÄ±n doÄŸruluÄŸu, teste ihtiyaÃ§ duymadan kanÄ±tlanmÄ±ÅŸ olurdu. SÃ¶zdizimi
ve anlamsallÄ±ÄŸÄ±n tam tanÄ±mlamasÄ±, bir dil iÃ§in otomatik olarak derleyici
oluÅŸturacak bir araÃ§ta kullanÄ±labilirdi.</code></pre><pre id="b5439efc-17c9-4519-a34c-b14d8585f246" class="code"><code>Dinamik Semantik Ã‡eÅŸitleri

Ä°ÅŸemsel Semantik
Denotasyonel Semantik
Aksiyomatik Semantik</code></pre><pre id="abbbffd5-b94c-4fda-b928-d8442c9fff75" class="code"><code>Ä°ÅŸlemsel semantik;

Ä°ÅŸlemsel anlamsallÄ±ÄŸÄ±n altÄ±nda yatan dÃ¼ÅŸÃ¼nce, bir program veya komutun
makinede Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda oluÅŸan etkileri tanÄ±mlamaktÄ±r. Makine Ã¼zerindeki
etkiler makinenin durumunun (state(register, memory...)) deÄŸiÅŸme sÄ±rasÄ± olarak izlenebilir. Burada
makinenin durumu, belleÄŸindeki deÄŸerler topluluÄŸudur. En basit tanÄ±mÄ±yla
iÅŸlemsel anlamsallÄ±k, bir kodun derlenmiÅŸ halini bilgisayarda Ã§alÄ±ÅŸtÄ±rmaktÄ±r.
BirÃ§ok programcÄ±, Ã¶zellikle bir dili yeni Ã¶ÄŸrenirken, bir yapÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±
anlamak iÃ§in kÃ¼Ã§Ã¼k bir test kodu yazar. Burada programcÄ±nÄ±n yaptÄ±ÄŸÄ±, yapÄ±nÄ±n
anlamÄ±nÄ±n ne olduÄŸuna bakmak iÃ§in iÅŸlemsel anlamsallÄ±k kullanmaktÄ±r.
TÃ¼m dilin resmi anlamsal tanÄ±mlamasÄ±nÄ± bu yaklaÅŸÄ±mla yapmak bir Ã§ok problemi
beraberinde getirir. Makine dili ve gerÃ§ek bilgisayarlar iÅŸlemsel anlamsallÄ±k iÃ§in
kullanÄ±lamazlar. Daha ziyade orta-seviyeli diller ve idealize edilmiÅŸ bilgisayarlar
bu iÅŸlem iÃ§in Ã¶zel olarak tanÄ±mlanmÄ±ÅŸtÄ±r. 
Bir sanal makinede Ã§alÄ±ÅŸÄ±r.</code></pre><pre id="53e8fa79-b154-4871-860a-fc5a2ec2bacb" class="code"><code>Ä°lk adÄ±m, ana Ã¶zelliÄŸi aÃ§Ä±klÄ±k (netlik) olan bir ara dil geliÅŸtirmektir. Bu ara dildeki
her yapÄ±nÄ±n aÃ§Ä±k ve belirli bir anlamÄ± olmalÄ±dÄ±r. GeliÅŸtirilecek dil, ara seviyede bir
dildir Ã§Ã¼nkÃ¼ makine dili anlaÅŸÄ±lmak iÃ§in Ã§ok dÃ¼ÅŸÃ¼k seviye kalmaktadÄ±r ve baÅŸka
yÃ¼ksek seviyeli bir dilin kullanÄ±mÄ± da tabiki uygun olmaz.
Ä°ÅŸlemsel anlamsallÄ±ÄŸÄ±n temel adÄ±mÄ± yabancÄ± bir kavram deÄŸildir. Aksine bu konu
programlama kitaplarÄ±ndan ve bir dile ait kullanÄ±m kÄ±lavuzlarÄ±ndan aÅŸina
olduÄŸumuz bir konudur. Ã–rneÄŸin C dilindeki for yapÄ±sÄ± daha basit komutlar
ÅŸeklinde tanÄ±mlanabilir:</code></pre><pre id="69f3b5c0-db98-4589-8142-3eda13ce2c59" class="code"><code>C ifadesi:

for(expr1;expr2;expr3) {
...
}

AnlamÄ±:

expr1;
loop: if expr2==0 goto out
â€¦ expr3;
goto loop
out: â€¦</code></pre><pre id="7a0e62b8-eb85-45d4-b2c1-8bbc44973352" class="code"><code>Ä°ÅŸlemsel semantiÄŸin bazÄ± problemleri vardÄ±r:
- Bir bilgisayarÄ±n memory&#x27;sinde ve registerinde Ã§ok fazla state vardÄ±r.
- GerÃ§ek bir bilgisayarÄ±n hafÄ±zasÄ± Ã§ok bÃ¼yÃ¼k ve karmaÅŸÄ±ktÄ±r.
- AÄŸa baÄŸlÄ± diÄŸer bilgisayarlarla yapÄ±lan baÄŸlantÄ±larda farklÄ± bellekler vardÄ±r. Yani
	her belleÄŸin state&#x27;ini bilmek Ã§ok zordur.
- Bu yÃ¼zden resmi bir gÃ¶sterim olarak kabul edilmez.
- Daha alt dil yapÄ±larÄ±na ve formlarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.

EÄŸer resmi bir ÅŸekilde kullanÄ±lmayacaksa, dilin el kitabÄ± gibi olacaksa problem yok,
kullanÄ±labilir.
Resmi bir ÅŸekilde kullanÄ±lacaksa karmaÅŸÄ±k olur. BazÄ± diller iÃ§in kullanÄ±lmÄ±ÅŸtÄ±r :(</code></pre><pre id="770d2343-0e5b-4bc2-bbcb-fa8b3ca93297" class="code"><code>Denotasyonel GÃ¶sterim;
Bu yÃ¶ntem, programlarÄ±n anlamÄ±nÄ± tanÄ±mlamada en yaygÄ±n olarak bilinen
yÃ¶ntemdir. Ã–zyinelemeli fonksiyon teorisi Ã¼zerine kurulmuÅŸtur. Bu yÃ¶ntemde,
dildeki herbir varlÄ±k iÃ§in bir matematiksel nesne ve o varlÄ±ÄŸÄ±n Ã¶rneklerini,
(instances) matematiksel nesnenin Ã¶rneklerine eÅŸleyen bir fonksiyon tanÄ±mlanÄ±r.
YÃ¶ntemin zorluÄŸu, nesneleri ve eÅŸleme fonksiyonlarÄ±nÄ± oluÅŸturmaktÄ±r.

- Bilinen en kesin/titiz yÃ¶ntem
- En soyut semantik yÃ¶ntemidir.

EÅŸleme fonksiyonunun sÃ¶zdizimsel domain&#x27;i tÃ¼m ikili sayÄ±larÄ±n string
gÃ¶sterimleri kÃ¼mesidir. Anlamsal domain&#x27;i ise pozitif onlu(decimal) sayÄ±lar
kÃ¼mesidir.
&quot;Seni seviyorum&quot; cÃ¼mlesinin yazÄ±mÄ± syntax domain, &quot;Seni seviyorum&quot; cÃ¼mlesinden
benim hocayÄ± sevdiÄŸim anlamÄ±nÄ± Ã§Ä±karmak semantic domain&#x27;dir.</code></pre><pre id="538033c2-8059-4fa2-b73e-052d1864d7d8" class="code"><code>Bir programÄ±n durumu, mevcuttaki tÃ¼m deÄŸiÅŸkenlerin deÄŸeridir.
Bir deÄŸiÅŸkenin ismi ve durum verildiÄŸinde deÄŸiÅŸkenin mevcut deÄŸerini versin
VARMAP(ij, s) = vj</code></pre><pre id="bf24b481-4e19-46a0-9873-8ce19c3cb1ae" class="code"><code>State(Durum) ve Ä°ÅŸlemsel vs notasyonel

Bir programÄ±n gÃ¶sterimsel anlamsallÄ±ÄŸÄ± ideal bir bilgisayardaki durum
deÄŸiÅŸiklikleri olarak tanÄ±mlanabilir. Ä°ÅŸlemsel anlamsallÄ±ÄŸÄ± da aynÄ± ÅŸekilde
tanÄ±mlamÄ±ÅŸtÄ±k. GÃ¶sterimsel anlamsallÄ±k programÄ±n sadece tÃ¼m deÄŸiÅŸkenlerinin
deÄŸerleri olarak tanÄ±mlanabilir. DolayÄ±sÄ±yla gÃ¶sterimsel anlamsallÄ±k, anlamÄ±
tanÄ±mlamak iÃ§in programÄ±n durumunu, iÅŸlemsel anlamsallÄ±k ise bilgisayarÄ±n
durumunu kullanÄ±r. AralarÄ±ndaki temel fark, iÅŸlemsel anlamsallÄ±kta durum
deÄŸiÅŸikliklerinin bir dilde kodlanmÄ±ÅŸ algoritmalarla, gÃ¶sterimsel anlamsallÄ±kta ise
matematiksel fonksiyonlarla tanÄ±mlanmasÄ±dÄ±r.


- Ä°ÅŸlemselde dilin yapÄ±larÄ±, yapÄ±nÄ±n temeli olan daha alt seviye dillere Ã§evrilir.
- Notasyonelde yapÄ±lar genelde matematiksel neseneler olan fonksiyonlarla gÃ¶sterilir
- Notasyonel semantik, programÄ±n adÄ±m adÄ±m hesaplamalÄ± iÅŸlemlerini modellemez.</code></pre><pre id="d09cd9e6-ce8a-4699-94ae-dab621008192" class="code"><code>ProgramlarÄ±n doÄŸruluÄŸunu kanÄ±tlamak iÃ§in kullanÄ±labilir.
Dil Ã¼retim sistemlerinde kullanÄ±lÄ±r.
Dil kullanÄ±cÄ±larÄ± iÃ§in karmaÅŸÄ±ktÄ±r.
Dil tasarÄ±mÄ±nda yardÄ±mcÄ± olabilir.
Programlar hakkÄ±nda dÃ¼ÅŸÃ¼nmek iÃ§in titiz bir yol saÄŸlar</code></pre><pre id="33a06bb4-adb6-4d9e-b566-4cf8a0a5113c" class="code"><code>Aksiyomatik semantik;

ProgramÄ±n anlamÄ±nÄ±
doÄŸrudan tanÄ±mlamak yerine, programla ilgili neyin ispat edilebileceÄŸini
tanÄ±mlar. Burada, anlamsallÄ±ÄŸÄ± tanÄ±mlamada programÄ±n doÄŸruluÄŸunu kanÄ±tlama
yÃ¶nteminin kullanÄ±ldÄ±ÄŸÄ±nÄ± hatÄ±rlamalÄ±yÄ±z. Aksiyomatik anlamsallÄ±kta, makinenin
veya programÄ±n durumunun modeli veya program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda oluÅŸan durum
deÄŸiÅŸikliklerinin modeli yoktur. ProgramÄ±n anlamÄ±, program deÄŸiÅŸkenleri ve
sabitleri arasÄ±ndaki iliÅŸkiyi temel alÄ±r.

BiÃ§imsel mantÄ±ÄŸa dayalÄ± (predicate calculus)
Temel amaÃ§: BiÃ§imsel program doÄŸrulama
Aksiyom ve Ã§Ä±karÄ±m kurallarÄ± dildeki tÃ¼m ifadeler iÃ§in tanÄ±mlanmÄ±ÅŸtÄ±r.
MantÄ±k ifadelerine assertions denir.

Ä°fadeden Ã¶nceki bir iddia(precondition/Ã¶nkoÅŸul) bu noktada doÄŸru olan, deÄŸiÅŸkenler
arasÄ±ndaki iliÅŸkileri belirtir
Bir ifadeyi izleyen bir iddia sonkoÅŸuldur(post condition)
Bir zayÄ±f Ã¶nkoÅŸul(weakest precondition) son koÅŸulu garanti etmek iÃ§in yeterli kÄ±sÄ±ttÄ±r</code></pre><figure id="46c2f30a-5d94-43c9-8915-bf3af9efb253" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/as%201.png"><img style="width:813px" src="Notlar%204688c028e1164aa39f523896ed3de007/as%201.png"/></a></figure><pre id="c91c8705-fa5f-4094-b5ce-b98619bdae38" class="code"><code>A&#x27;nÄ±n 1&#x27;den bÃ¼yÃ¼k olabilmesi iÃ§in b&#x27;nin en zayÄ±f koÅŸulu b&gt;0&#x27;dÄ±r. Ama herhangi
bir deÄŸer almasÄ± da mÃ¼mkÃ¼ndÃ¼r.</code></pre><pre id="b097395b-64c0-4442-9d29-438a37aeb0ce" class="code"><code>Bir program iÃ§in son istenen sonuÃ§ son koÅŸuldur.

ProgramÄ±n baÅŸÄ±na doÄŸru geri Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

EÄŸer Ã¶nkoÅŸul, programÄ±n belirtimiyle aynÄ±ysa program doÄŸrudur.

Ã‡Ä±karÄ±m kuralÄ±; Ã¶nceki iddianÄ±n doÄŸruluÄŸunu diÄŸer iddialarÄ±n doÄŸruluklarÄ±na baÄŸlÄ± olarak
Ã§Ä±karÄ±m yapan bir yÃ¶ntemdir.</code></pre><figure id="6cddd830-4719-4240-8c72-e96ad2fe45c4" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_163353.png"><img style="width:720px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_163353.png"/></a></figure><pre id="f213181f-656f-4e58-ab2e-dee1f692e22e" class="code"><code>Bir Ã§Ä±karÄ±m kuralÄ±nÄ±n genel formu yukarÄ±daki gibidir.

EÄŸer S1, S2..., Sn doÄŸru ise S&#x27;nin de doÄŸru olduÄŸu Ã§Ä±karÄ±mÄ±na varÄ±lÄ±r.

Åekildeki Ã¼st kÄ±sma Ã¶ncÃ¼l, alt kÄ±sma sonuÃ§ denir.</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9f25fe59-e2cf-40b9-a676-4a6e6e89c2ce"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">Aksiyom:
DoÄŸruluÄŸu iÃ§in baÅŸka bir Ã¶ncÃ¼le ihtiyaÃ§ duymayan, doÄŸruluÄŸu kabul edilen Ã§Ä±karÄ±m
kuralÄ±dÄ±r. </div></figure><figure id="9c4af099-9b58-40f0-a7bd-64ee92d2c2da" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_164412.png"><img style="width:672px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_164412.png"/></a></figure><pre id="2affeab8-8974-4368-aefe-ed81cb9362f1" class="code"><code>YukarÄ±daki bence gayet aÃ§Ä±klayÄ±cÄ± :D</code></pre><figure id="e02d6186-0c52-4b33-b99c-c07f6c7eb08c" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_164613.png"><img style="width:672px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2021-11-25_164613.png"/></a></figure><pre id="056bb758-e5ec-4bc0-81e9-eae44aeacb1a" class="code"><code>Ã–rnek-2&#x27;de x&#x27;in son koÅŸulunu(x&gt;25) saÄŸlayan y&#x27;nin Ã¶nkoÅŸulunu bulmak iÃ§in matematiksel
iÅŸlemler yapÄ±yoruz.

Ã–rnek-3&#x27;te x&#x27;in son koÅŸulunu(x&gt;10) saÄŸlayan, y&#x27;nin Ã¶nkoÅŸulunu bulmamk iÃ§in matematiksel
iÅŸlemler yapÄ±yoruz.

Ã–rnek-4&#x27;te x&#x27;e Ã¶nkoÅŸul olarak verilen x&gt;3 koÅŸulu, son koÅŸulu(x&gt;0) saÄŸlÄ±yor mu diye
bakÄ±yoruz</code></pre><pre id="a81f2c57-55fc-41b7-be9a-0a23ad732378" class="code"><code>Hem Ã¶nkoÅŸul hem sonkoÅŸul iÃ§eren bir atama ifadesi, &#x27;mantÄ±ksal bir ifade&#x27; ya da
&#x27;teorem&#x27; olarak kabul edilir.</code></pre><pre id="28ad0f16-25e5-4e16-8bd5-def95f1e0a98" class="code"><code>- Bir dilde tÃ¼m ifadeler iÃ§in aksiyom ve Ã§Ä±karÄ±m kurallarÄ± geliÅŸtirmek zordur.

- DoÄŸruluk kanÄ±tlarÄ± iÃ§in iyi bir araÃ§tÄ±r ve programlar hakkÄ±nda muhakeme iÃ§in mÃ¼kemmel
bir Ã§erÃ§evedir. Ancak dil kullanÄ±cÄ±larÄ± ve derleyici yazarlarÄ± iÃ§in deÄŸildir.</code></pre><h1 id="5569050b-dc4a-4530-b9f3-db2ebe61fb13" class="">Vize SonrasÄ±</h1><pre id="07e5f5eb-2e93-419a-9fa2-3827a3343339" class="code"><code>Bir dil iÅŸlemci, iki kÄ±sÄ±mdan oluÅŸur:
Lexical analyzer
Syntax analyzer

Lexical analyzer, syntax analyzer&#x27;Ä±n bir dalÄ±dÄ±r aslÄ±nda. Ancak ayrÄ± deÄŸerlendirilirler.

Lexical analyzer&#x27;Ä±n, syntax analyzer&#x27;dan ayrÄ±lma nedenleri:
	- Syntax analyzer biraz platform baÄŸÄ±mlÄ±dÄ±r.
	- lexical analyzer&#x27;Ä± kÃ¼Ã§Ã¼ltÃ¼p optimize etmek. Syntax analyzer&#x27;Ä± optimize etmek verimli
		deÄŸil
	- Lexical analyzer daha basit. AyÄ±rarak karmaÅŸayÄ± azaltmak</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0f16953f-c65e-43c4-9287-54f77fe6ad77"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">Boolean isTrue = parser == syntaxAnalyzer
// isTrue: true</div></figure><pre id="42f5729c-3039-4a4a-b35e-f7c8c1c32ec4" class="code"><code>Dil iÃ§erisinde birim olarak kullanÄ±lan alfabetik karakter serilerine
anahtar kelimeler denir.

AyrÄ±lmÄ±ÅŸ kelime ve genellikle deÄŸiÅŸken ismi olarak kullanÄ±lmasÄ±na izin
verilmez.

Semboller (&gt;,&lt;,=,! vb.) programlama dilinde birim olarak kullanÄ±lÄ±rlar.</code></pre><pre id="9da8fa8b-1bbd-47a3-be37-b52db9171f0a" class="code"><code>â€¢ Bir PDâ€™de en dÃ¼ÅŸÃ¼k dÃ¼zeyli sÃ¶zdizimsel birimlere lexeme adÄ± verilir.
â€¢ Programlar, karakterler yerine lexemeâ€™ler dizisi olarak dÃ¼ÅŸÃ¼nÃ¼lebilir.
â€¢ Bir dildeki lexemeâ€™lerin gruplanmasÄ± ile dile ait tokenâ€™lar oluÅŸturulur.
â€¢ Programlama dilinin metinsel sÃ¶zdizimi tokenâ€™lar ile tanÄ±mlanÄ±r.
â€¢ Ã–rneÄŸin bir tanÄ±mlayÄ±cÄ± (identifier); Â«ortalamaÂ» ve Â«kÃ¶kÂ» gibi lexemeâ€™leri
	olan bir tokenâ€™dÄ±r.
â€¢ BazÄ± durumlarda bir tokenâ€™Ä±n sadece tek bir lexemeâ€™i vardÄ±r.
â€“ Ã‡Ä±karma_OperatÃ¶rÃ¼ â€˜-â€™
â€¢ BoÅŸluk, ara veya yeni satÄ±r karakterleri, tokenâ€™lar arasÄ±na yerleÅŸtiÄŸinde bir
	programÄ±n anlamÄ± deÄŸiÅŸmez.</code></pre><pre id="3662cc48-a005-46e6-adc5-d242a0effa04" class="code"><code>SÃ¶zcÃ¼ksel Ã‡Ã¶zÃ¼mleyici (Lexical Analyzer)

â€¢ Karakter dizileri iÃ§in bir Ã¶rÃ¼ntÃ¼ eÅŸleÅŸtirici (pattern matcher)
â€¢ AyrÄ±ÅŸtÄ±rÄ±cÄ±nÄ±n baÅŸlangÄ±Ã§ aÅŸamasÄ± (â€˜front-endâ€™ of parser)
â€¢ Birbirine ait olan kaynak programÄ±n alt karakter dizilerini tanÄ±mlar â€“
	lexemes
â€“ Bulunan lexemeâ€™lar kategorilerini belirten tokenâ€™larla eÅŸleÅŸtirilir.
â€“ sum bir lexeme; onun tokenâ€™Ä± IDENT olabilir
â€¢ Verilen bir girdi stringâ€™den lexemeâ€™leri Ã§Ä±karÄ±r ve onunla ilgili tokenâ€™larÄ±
	Ã¼retir.
â€¢ KullanÄ±cÄ± tanÄ±mlÄ± isimler iÃ§in lexemeâ€™larÄ± sembol tablosuna ekler.
â€¢ Tokenlarâ€™daki sÃ¶zdizimsel hatalarÄ± tespit eder ve kullanÄ±cÄ±ya bildirir.
â€“ Bozuk biÃ§imlendirilmiÅŸ kayan nokta deÄŸiÅŸmezleri</code></pre><pre id="c02dac8c-4e7c-4808-89c0-579263a2735a" class="code"><code>Lexical analyzer&#x27;lar ilk zamanlarda tÃ¼m programlarÄ± iÅŸleyip karÅŸÄ±lÄ±k gelen tokenleri
Ã¼retirdi.

Ancak bu zamanda lexical analyzer; SÃ¶zcÃ¼ksel Ã§Ã¶zÃ¼mleyicilerin Ã§oÄŸu kendisine verilen
input iÃ§erisinde ki bir sonraki lexemeâ€™i ve karÅŸÄ±lÄ±k gelen tokenâ€˜Ä±, kendisini Ã§aÄŸÄ±ran
programa (sÃ¶zdizim Ã§Ã¶zÃ¼mleyicisine) dÃ¶ndÃ¼ren bir alt programdÄ±r.

SÃ¶zdizim Ã§Ã¶zÃ¼mleyicisinin her defasÄ±nda gÃ¶rdÃ¼ÄŸÃ¼ tek ÅŸey o
anda sÃ¶zcÃ¼ksel Ã§Ã¶zÃ¼mleyicisinden gelen tek tokenâ€™dÄ±r.</code></pre><pre id="8faea00a-6326-4248-b75d-e60b70128faf" class="code"><code>Sembol Tablosu

â€¢ Derleme sÃ¼recinde programdaki her tanÄ±mlayÄ±cÄ± iÃ§in bir eleman iÃ§eren
	sembol tablosu oluÅŸturulur.
â€¢ Sembol tablosu, derleme sÃ¼recindeki Ã§eÅŸitli aÅŸamalarda kullanÄ±lÄ±r ve
	gÃ¼ncellenir.
â€¢ Bir tanÄ±mlayÄ±cÄ± kaynak programda ilk kez bulunduÄŸunda, o tanÄ±mlayÄ±cÄ± iÃ§in
	sembol tablosunda bir eleman oluÅŸturulur.
â€¢ AynÄ± tanÄ±mlayÄ±cÄ±nÄ±n daha sonraki kullanÄ±mlarÄ± iÃ§in ilgili token, aynÄ± sembol
	tablosu elemanÄ±na baÅŸvuru iÃ§erir.
â€¢ SÃ¶zcÃ¼ksel Ã§Ã¶zÃ¼mleme aÅŸamasÄ±nÄ±n sonunda, programdaki token&#x27;lar ve her
	token&#x27;Ä±n Ã¶zelliklerinin tutulduÄŸu sembol tablosu elemanÄ±na iÅŸaret edilen
	gÃ¶stergeleri iÃ§eren token dizisi oluÅŸturulur.</code></pre><figure id="e1046122-6380-44f0-8421-a950d698fc62" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_111509.png"><img style="width:758px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_111509.png"/></a></figure><figure id="778de2da-48bc-42c8-9b83-f49c1456e32f" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_111523.png"><img style="width:839px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_111523.png"/></a></figure><figure id="1cbb14c3-9f90-48e1-bfa0-4420b7567f9a" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_112251.png"><img style="width:672px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_112251.png"/></a></figure><h2 id="fe88a49e-188f-4592-9f1d-6ce7630ca6b9" class="">DeÄŸiÅŸkenler</h2><pre id="024ab710-02eb-4521-ae2d-96d742a56724" class="code"><code>Von Neumann mimarisi, her bellek hÃ¼cresinin Ã¶zgÃ¼n bir adres ile
tanÄ±mlandÄ±ÄŸÄ± ana bellek kavramÄ±na dayanmaktadÄ±r.

â€¢ Emirsel Diller (Imperative languages) von Neumann mimarisinin
	soyutlanmasÄ±dÄ±r.
â€¢ Imperative (Emirsel) programlama, von Neumann mimarisindeki
	bilgisayarlara uygun olarak programlarÄ±n iÅŸlem deyimleri ile
	deÄŸiÅŸkenlerin bellekteki deÄŸerleri deÄŸiÅŸtirmesine dayanÄ±r.
â€¢ DeÄŸiÅŸkenler belirli Ã¶zellikler ile karakterize edilir.
	â€“ Ad, adres, tip, deÄŸer, yaÅŸam sÃ¼resi, kapsam</code></pre><pre id="8883bd8e-bd50-49e8-88b9-d4e031c5facb" class="code"><code>DeÄŸiÅŸken isimleri

Bellek hÃ¼crelerini refere eden deÄŸiÅŸkenlerin isimleri vardÄ±r.
Her dilin reserved keyword&#x27;leri vardÄ±r.

Ä°simler Ã§ok kÄ±sa olursa anlamlÄ± olmaz.
BazÄ± dillerde ismin kaÃ§ karakterden oluÅŸacaÄŸÄ± sÄ±nÄ±rlÄ±dÄ±r.
Ä°simler, hiÃ§bir dilde harf ya da Ã¶zel karakterlerle baÅŸlayamaz.
BazÄ± diller bÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r. Bunun kÃ¶tÃ¼ yanÄ± okunabilirdiÄŸi etkilemesidir.</code></pre><pre id="30023a00-e705-4962-a818-3b412a395a1a" class="code"><code>Bir anahtar kelime (keyword), bir programlama dilinin sadece belirli
iÃ§eriklerde Ã¶zel anlam taÅŸÄ±yan kelimelerini gÃ¶stermektedir.

â€¢ Ã–rneÄŸin FORTRAN&#x27;da REAL kelimesi, bir deyimin baÅŸÄ±nda yer alÄ±p,
	bir isim tarafÄ±ndan izlenirse, o deyimin tanÄ±mlama deyimi olduÄŸunu
	gÃ¶sterir. (REAL apple)
	real x;
	
â€¢ EÄŸer REAL kelimesi, atama iÅŸlemcisi &quot;=&quot; tarafÄ±ndan izlenirse, bir
	deÄŸiÅŸken ismi olarak gÃ¶rÃ¼lÃ¼r. REAL = 10.05 gibi.
	real=5;
â€¢ Bu durum dilin okunabilirliÄŸini azaltÄ±r.

Reserved word, dil iÃ§in ayrÄ±lmÄ±ÅŸ, Ã¶zel anlamÄ± olan ve kullanÄ±cÄ± tarafÄ±ndan asla
kullanÄ±lmayacak olan kelimelerdir.
- For, while, switch...</code></pre><pre id="15cd4058-6cfb-4943-8a72-3ca1c32257eb" class="code"><code>â€¢ Bir deÄŸiÅŸken, yÃ¼rÃ¼tme sÄ±rasÄ±nda farklÄ± zamanlarda farklÄ± adreslere sahip
	olabilir
â€¢ AynÄ± bellek konumuna eriÅŸmek iÃ§in iki deÄŸiÅŸken adÄ± kullanÄ±labilirse,
	bunlar takma ad (alias) olarak adlandÄ±rÄ±lÄ±r</code></pre><pre id="2ae92a57-08f0-4fac-bd90-dd51e1ba8a62" class="code"><code>Binding (BaÄŸlama)

Bir Ã¶zellikle bir program elemanÄ± arasÄ±nda iliÅŸki kurulmasÄ±na baÄŸlama
(binding) denir.

BaÄŸlama kavramÄ± programlama dillerinde yaygÄ±n ve programÄ±n her safhasÄ±nda
gerÃ§ekleÅŸebilen bir kavramdÄ±r
â€“ DeÄŸiÅŸkenler tiplerine veya deÄŸerlerine baÄŸlanÄ±r.
â€“ Bir iÅŸlem bir sembole baÄŸlanÄ±r.

BaÄŸlama ZamanlarÄ±

- Language Design Time
- Language implemenation time
- Compile time
- Load time
- Runtime</code></pre><figure id="705ee3b9-fbda-4af7-949b-3e33f221ac61" class="image"><a href="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_131405.png"><img style="width:849px" src="Notlar%204688c028e1164aa39f523896ed3de007/Ekran_grnts_2022-01-09_131405.png"/></a></figure><pre id="2a482a35-6609-473c-a85b-4f4f43fd1951" class="code"><code>Statik Tip BaÄŸlama: deÄŸikenlerin tiplerinin derleme zamanÄ±nda belirlenmesidir.
Dimamik Tip BaÄŸlama: deÄŸiÅŸken tiplerinin runtime&#x27;da belirlenmesidir.

Explicit type binding: Tiplerin tanÄ±mlanÄ±rken aÃ§Ä±kÃ§a bildirilmesi (static typing)
Implicit type binding: Verilen deÄŸerlerden tipin Ã§Ä±kartÄ±lmasÄ±

Allocation: kullanÄ±labilir hafÄ±za havuzundan yer alÄ±nmasÄ±
Deallocation: hafÄ±za havuzuna bellek hÃ¼cresini geri verme

DeÄŸiÅŸkenin yaÅŸam sÃ¼resi (lifetime): DeÄŸiÅŸkenin, belirli bir bir bellek hÃ¼cresiyle
baÄŸlanmasÄ± ile bu baÄŸÄ±n koparÄ±lmasÄ± arasÄ±nda geÃ§en sÃ¼redir</code></pre><pre id="066f49c6-26af-488f-871b-b9e517762eb2" class="code"><code>HafÄ±za bÃ¶lÃ¼mleri

- Kod
- Stack: FonksiyonlarÄ±n aktivason kaydÄ± tutulur
- Heap: Dinamik olarak tahsis edilen, kullanÄ±cÄ± tarafÄ±ndan kullanÄ±lan bellek alanÄ±dÄ±r.</code></pre><pre id="702293fc-55e6-45ef-8ff8-4c4eedfe9c17" class="code"><code>Statik DeÄŸiÅŸkenler

ProgramÄ±n bÅŸlangÄ±cÄ±nda belleÄŸe baÄŸlanÄ±r ve program bitince kaldÄ±rÄ±lÄ±r.
BurasÄ± iÃ§in gerekli bellek, program baÅŸlamdan ayrÄ±lÄ±r (Load time)
C++ ve java&#x27;da ststic kelimesiyle tanÄ±mlanÄ±r.</code></pre><pre id="916766e7-1445-4acf-bf9d-395975db3234" class="code"><code>Kapsam (Scope)

Scope(kapsam): Bir deÄŸiÅŸkenin visible olduÄŸu yer/yerler

Local variables: TanÄ±mlandÄ±ÄŸÄ± blok iÃ§erisinde geÃ§erli olan deÄŸiÅŸkenlerdir.
Non-local variables: TanÄ±mlandÄ±ÄŸÄ± yer dÄ±ÅŸÄ±nda eriÅŸebilen deÄŸiÅŸkenlerdir.

Global deÄŸiÅŸkenler, non-local deÄŸiÅŸkenlerin alt bir kÃ¼mesidir.</code></pre><pre id="036e7d06-eebb-4f20-9bd6-542b3348739d" class="code"><code>Statik Kapsam

ProgramÄ±n yazÄ±sÄ±ndan anlaÅŸÄ±labilir.
Ä°lk olarak bulunduÄŸu kapsamda deÄŸiÅŸken var mÄ± diye deÄŸÄŸiÅŸken aranÄ±r. EÄŸer bulunamazsa
gittikÃ§e bir Ã¼st kapsama Ã§Ä±kÄ±lÄ±r. </code></pre><pre id="00f6f60f-0f77-4f9f-b254-46ac80125444" class="code"><code>Blok: Deyimlerin bir araya getirilmesi ile oluÅŸturulan ve bu deyimlere Ã¶zgÃ¼ yerel
deÄŸiÅŸkenlerin tanÄ±mlanabildiÄŸi kod bÃ¶lÃ¼mÃ¼ne blok adÄ± verilir.</code></pre><pre id="e051a92e-a650-4f68-96c0-60ec596d83cf" class="code"><code>Dinamik Kapsam

â€¢ Bir ismin kapsamÄ±nÄ±n, altprogramlarÄ±n fiziksel yakÄ±nlÄ±klarÄ±na gÃ¶re deÄŸil,
	altprogramlarÄ±n Ã§aÄŸrÄ±lma sÄ±rasÄ±na gÃ¶re Ã§alÄ±ÅŸma zamanÄ±nda belirlenmesi dinamik
	kapsam olarak adlandÄ±rÄ±lÄ±r.
â€¢ Bu durumda bir isim tanÄ±mÄ±, Ã§alÄ±ÅŸma sÄ±rasÄ±nda aynÄ± isimde yeni bir tanÄ±mlama
	bulunana kadar, kendisinden sonra Ã§alÄ±ÅŸtÄ±rÄ±lan tÃ¼m komutlarda geÃ§erlidir</code></pre><pre id="76e0a62f-ae50-4b3e-b489-244bf5bff6fa" class="code"><code>Referencing Environments

Bir ifadenin referans ortamÄ±, ifadede gÃ¶rÃ¼nen tÃ¼m isimlerin toplamÄ±dÄ±r.</code></pre><pre id="fed0978e-0e55-4baa-bc83-017f65083a5d" class="code"><code>Statik kapsamda bir fonksiyon bir fonksiyonu Ã§aÄŸÄ±rdÄ±ÄŸÄ±nda, Ã§aÄŸÄ±ran fonksiyon ve
deÄŸiÅŸkenleri bir aktivasyon kaydÄ±nda tutulur ancak lifetime hala canlÄ±dÄ±r.</code></pre><pre id="d6015cad-b476-455f-a6f5-3e5f1555928e" class="code"><code>Ä°lkel Veri Tipleri

MantÄ±ksal (true - false)
Decimal (10,20,-100)
Floating Point (float)</code></pre><pre id="4a10560e-1f35-4cb0-ba07-cf10ffa39caf" class="code"><code>Karakter katarÄ±

C ve C++&#x27;ta temel veri tipi deÄŸildir. ManipÃ¼le iÅŸlemleri iÃ§in fonksiyon iÃ§eren
kÃ¼tÃ¼phaneleri mevcuttur.

Java&#x27;da String ile ilkel veri tipidir.
Python&#x27;da da ilkel veri tipidir.

C ve C++&#x27;ta limitli dinamik uzunluk vardÄ±r. UzunluÄŸunu kaydetmek yerine dizenin
bittiÄŸini belirtmek iÃ§in Ã¶zel bir karkater 36
kullanÄ±r. (e.g: &#x27;\0&#x27;)
Javascript dinamik uzunluktadÄ±r. Max uzunluk yoktur.</code></pre><pre id="cdde7daf-e792-4ea0-84d7-2d0f9974d1c0" class="code"><code>Dinamik uzunluktaki stringler iÃ§in dynamic allocation and deallocation methods

- String elemanlarÄ±nÄ± linked list ile tutmak. Yeni bir eleman eklendiÄŸinde heap bellekte
	herhangi bir yere eklenebilir.
	Her string elemanÄ± iÃ§in struct tutulacaÄŸÄ± iÃ§in sonraki elemanÄ±n adresini tutmak extra
	maliyettir. 
- String karakterlerini bir pointer dizisi gibi sÄ±ralÄ± tutmaktÄ±r.AnladÄ±ÄŸÄ±m kadarÄ±yla
	yine linked list gibi olacak ama karakterlerin pointer&#x27;leri dizi olarak tutuluyor.
	Ama elbette bu da ekstra hafÄ±za kaplÄ±yor.
- String&#x27;i bir dizi gibi sÄ±ralÄ± ÅŸekilde tutmak. Ama bunda da yeni eleman eklemek
	sÄ±kÄ±ntÄ± olur. Diziyi alÄ±p yeni bir yere taÅŸÄ±mak gerrekir yer kalmazsa. Hep maliyet</code></pre><pre id="e5a3719d-a7b9-4d98-adb6-5efa34d43954" class="code"><code>SayÄ±lama tipleri(Enums): Const gibi bir ÅŸey. Ä°simleri tanÄ±mlama sÄ±rasÄ±nÄ±n numaralarÄ±yla
eÅŸleÅŸtirir.

enum days {mon, tue, wed, thu, fri, sat, sun};
mon: 1  thu: 4  sun: 7
tue: 2  fri: 5
wed: 3  sat: 6  </code></pre><pre id="fe1677aa-34c1-45ce-b51d-fd56b118b7b3" class="code"><code>Linked list hafÄ±za yemesine ve iÅŸlemler uzun sÃ¼rmesine raÄŸmen allocation ve deallocation
daha hÄ±zlÄ±dÄ±r.

Karakter dizisi olarak tutulmasÄ± hafÄ±za ve hÄ±z aÃ§Ä±sÄ±ndan iyidir. Ancak allocation ve 
deallocation daha yavaÅŸtÄ±r.</code></pre><pre id="bd09430e-eacb-4e19-ad6f-5006cfdafa58" class="code"><code>Diziler</code></pre><pre id="6c3b9409-9148-4d73-8851-af0cbf1d6917" class="code"><code>Bellek YÃ¶netimi

Ã‡alÄ±ÅŸan herhangi bir programdaki deÄŸiÅŸkenler, sÄ±nÄ±flar,metotlar
bellekte bir yerde tutulurlar.
ÃœÃ§ tÃ¼r bellek vardÄ±r:
	- Statik
	- Heap
	- Stack
</code></pre><pre id="4f4e7f47-bb9b-4af3-b4f6-49a6f7c2c724" class="code"><code>Statik Bellek AlanÄ±

Bu bÃ¶lgede yer alacak deÄŸiÅŸkenlerin hangiler olduÄŸu, program baÅŸlamadan bellidir.
Load time&#x27;da belleÄŸe yazÄ±lÄ±rlar.
â€¢ Bu bÃ¶lgede tutulanlar;
â€“ Global deÄŸiÅŸkenler,
â€“ Sabitler,
â€“ Static olarak tanÄ±mlanmÄ±ÅŸ lokal deÄŸiÅŸkenler
â€¢ Program Ã§alÄ±ÅŸtÄ±ÄŸÄ± sÃ¼rece var olurlar, program sonlandÄ±ÄŸÄ±nda bellekten silinirler.
â€¢ Global deÄŸiÅŸkenler program sonlanÄ±ncaya kadar bellekte tutulacak ve herhangi bir
	satÄ±rda eriÅŸilebilecektir. DeÄŸiÅŸip deÄŸiÅŸmediklerinin kontrolÃ¼ zor olduÄŸu iÃ§in
	kullanÄ±mÄ± tavsiye edilmemektedir.</code></pre><pre id="41bd274d-18fe-470a-964f-f84972425223" class="code"><code>Stack Bellek AlanÄ±

Bu bellek bÃ¶lgesinde fonksiyonlar ve yerel deÄŸiÅŸkenler tutulur. Fonksiyonlar ve yerel
deÄŸiÅŸkenler Ã§alÄ±ÅŸma zamanÄ±nda belleÄŸe eklenir. Ã‡alÄ±ÅŸma zamanÄ±nda daralÄ±p geniÅŸleyebilir.

Fonksiyon veya metot Ã§aÄŸrÄ±lan yere dÃ¶ndÃ¼ÄŸÃ¼nde Ã§alÄ±ÅŸma anÄ± yÄ±ÄŸÄ±nÄ±nda ayrÄ±lmÄ±ÅŸ olan yer
geri dÃ¶ndÃ¼rÃ¼lÃ¼r.
Bu deÄŸiÅŸkenlere Ã§aÄŸrÄ±m bittikten sonre eriÅŸim olmayacaktÄ±r ve fonksiyon iÃ§in aÃ§Ä±lan
aktivasyon kaydÄ± sonlanÄ±r.</code></pre><pre id="af1a579c-20ad-4317-806b-5f3ae049c10d" class="code"><code>Heap Bellek BÃ¶lgesi

Ã‡alÄ±ÅŸma zamanÄ±nda daralÄ±p geniÅŸleyen bir bÃ¶lgedirr. C ve C++&#x27;ta kullanÄ±cÄ±nÄ±n kontrolÃ¼ne
bÄ±rakÄ±lmÄ±ÅŸtÄ±r.
Java&#x27;da new kelimesi ile yer ayrÄ±lÄ±r.
C&#x27;de ise malloc ise yer ayrÄ±lÄ±r.
AyrÄ±lan bÃ¶lgelere, pointer&#x27;lar yarÄ±mÄ±yla eriÅŸilir.

AyrÄ±lan yerler geri verilmelidir. Yoksa Ã§Ã¶p denen yerler oluÅŸacaktÄ±r.
Bu Ã§Ã¶pler Java&#x27;da Garbage Collector tarafÄ±ndan otomatik olarak toplanÄ±r.
C&#x27;de ise bu, free() fonskiyonu yardÄ±mÄ±yla yapÄ±lÄ±r. KullanÄ±cÄ± kendisi Ã§Ã¶p toplamayÄ± yapar</code></pre><pre id="fc88c23c-4308-4aee-9869-cf4d3dfb29aa" class="code"><code>Ä°ndislerin BaÄŸlanmasÄ± ve Dizi Kategorileri

Static: Indisler derlenme zamanÄ±nda baÄŸlanÄ±r ve bir daha deÄŸiÅŸmez. Etkili ve hÄ±zlÄ±dÄ±r.
				Program baÅŸlarken hafÄ±zaya oturur ve bitene kadar kalkmaz.

Fixed Stack Dynamic: Compile time&#x27;da dizi boyutu bilinir. Ancak dizinin bulunduÄŸu
				kapsamda boyutu daraltÄ±lÄ±p geniÅŸletilebilir. Kapsam bitince eklenen ya da
				Ã§Ä±karÄ±lan indisler temizlenip dizi Ã¶nceki haline dÃ¶ner.

Fixed Heap Dynamic:  fixed stack dynamic gibidir. Ancak heap&#x27;te yer ayrÄ±lacaÄŸÄ± aÃ§Ä±kÃ§a 
				belirtilir.
			
Heap Dynamic: Ã‡alÄ±ÅŸma zamanÄ±nda tanÄ±mlanÄ±p daraltÄ±lÄ±p geniÅŸletilebilmektedir.</code></pre><pre id="23f20efc-6327-4f37-a166-def1b3e974fc" class="code"><code>Records

Alt alan olarak isimlendirilen birden fazla ifadenin bulunduÄŸu yapÄ±dÄ±r.

FarkltÄ± tipte birden fazla alan tanÄ±mlanabilir.

Records&#x27;a eriÅŸim diziye eriÅŸimden daha hÄ±zlÄ±dÄ±r. Ã‡Ã¼nkÃ¼ record dinamiktir</code></pre><pre id="7a50ddc4-7985-46dc-8328-fff24fc62a71" class="code"><code>Tuple Type

DeÄŸiÅŸtirilemeyen dizilerdir denebilir.</code></pre><pre id="08209a4b-1726-4396-8bc4-b2c0fff2d976" class="code"><code>Union

Ä°Ã§ine veri tipleri koyulabilen bir veri tipidir. Struct&#x27;a benzemektedir.
Struct&#x27;ta birden fazla veri tipi depolanabilmesine ve her birinin farklÄ± hafÄ±za
bÃ¶lgeleri olmasÄ±na karÅŸÄ± union&#x27;da da birden fazla veri tipi depolanabilir ama union&#x27;un
boyutu, iÃ§indeki en bÃ¼yÃ¼k veri tipinin boyutu kadardÄ±r.
Yani union iÃ§inde aynÄ± anda sadece bir veri depolanabilir. BaÅŸka bir proprty&#x27;e bir deÄŸer
yazÄ±lsa da diÄŸer property&#x27;deki veriler silinir.</code></pre><pre id="9fb173fd-6ad5-42d0-82cd-503f2549da31" class="code"><code>KÃ¼me veri tipi

Ä°Ã§inde aynÄ± veriden sadece bir tane bulundurabilen dizilerdir.</code></pre><pre id="0b36a28b-d21c-49f9-9cff-d77486960fe6" class="code"><code>Pointers

BaÅŸka bir bellek alanÄ±nÄ±n adresini gÃ¶steren veri tipidir.
Sabit bÃ¼yÃ¼klÃ¼ktedirler ve genelde tek bir bellek alanÄ±na sÄ±ÄŸarlar.

Dangling pointer: Pointer&#x27;in gÃ¶sterdiÄŸi bellek hÃ¼cresindeki deÄŸer silindiÄŸinde ya da 
deÄŸiÅŸtirildiÄŸinde pointer artÄ±k boÅŸ bir yeri ya da deÄŸiÅŸik bir deÄŸeri gÃ¶stercektir.
Bu bÃ¼yÃ¼k bir risktir.</code></pre><pre id="07d6deab-0b28-4334-ae71-d13951e31a1d" class="code"><code>Kuvvetli Tipleme

FarklÄ± veri tiplerinin etkileÅŸimlerinin kÄ±sÄ±tlanmasÄ±na denir.

Bir programlama dili, programdaki bÃ¼tÃ¼n tip hatalarÄ±nÄ± yakalÄ±yorsa kuvvetli
tipli dil denilebilir.

Derleyici, her deÄŸiÅŸken ve her ifadenin tipini belirleyecek kurallara sahiptir.

Uyumlu olmayan tiplerin birbirine atanmasÄ±na izin verilmez.</code></pre><pre id="cd9fcacb-ffd8-4e2c-9781-c6ca90ee9380" class="code"><code>Tip DÃ¶nÃ¼ÅŸÃ¼mÃ¼

	Bir tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼nde bir nesne, kendi tipindeki tÃ¼m deÄŸerleri iÃ§ermeyen bir tipe
	dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yorsa bu tip dÃ¶nÃ¼ÅŸÃ¼me daralan dÃ¶nÃ¼ÅŸÃ¼m denir.
â€“ Kayan noktalÄ± sayÄ± tipinden -&gt; tamsayÄ± tipine
â€“ Hatalar oluÅŸabileceÄŸinden gÃ¼venli deÄŸildir.
â€¢ EÄŸer bir deÄŸiÅŸkenin kendi tipinin tÃ¼m deÄŸerlerini iÃ§eren bir tipe dÃ¶nÃ¼ÅŸÃ¼mÃ¼
	gerÃ§ekleÅŸiyorsa bu dÃ¶nÃ¼ÅŸÃ¼me geniÅŸleyen dÃ¶nÃ¼ÅŸÃ¼m denir.
â€“ TamsayÄ± tipinden -&gt; kayan noktalÄ± sayÄ± tipine
â€“ Daha gÃ¼venli bir dÃ¶nÃ¼ÅŸÃ¼m
â€¢ Derleyici tarafÄ±ndan gerÃ§ekleÅŸtirilen ve zorunlu dÃ¶nÃ¼ÅŸÃ¼m olarak adlandÄ±rÄ±lan bu tip
	dÃ¶nÃ¼ÅŸÃ¼mlerine Ã¶rtÃ¼lÃ¼ (implicit) dÃ¶nÃ¼ÅŸÃ¼m denir</code></pre><p id="d1646ad2-ab4d-49a9-9701-ec3a0bae9d67" class="">
</p></div></article></body></html>