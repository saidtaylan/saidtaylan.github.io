<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Bilgisayar mimarisi</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="6a5289cb-2f44-42ca-acc9-7b2f99d9676a" class="page sans"><header><img class="page-cover-image" src="https://beningo-embedded-group.s3.amazonaws.com/2020/06/AdobeStock_135663532-825x510.jpeg" style="object-position:center 9.319999999999995%"/><h1 class="page-title">Bilgisayar mimarisi</h1></header><div class="page-body"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b8df25b1-2518-4de5-b2c3-4572a84fe48d"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">HocanÄ±n slaytlarÄ±ndan daha uzun olmuÅŸ olabilir ğŸ˜…

Ama her slaytÄ± kendi anladÄ±ÄŸÄ±m ÅŸekilde oldukÃ§a aÃ§Ä±klayÄ±cÄ± bir ÅŸekilde anlatmaya Ã§alÄ±ÅŸtÄ±m ğŸ¤¯

DÃ¶kÃ¼mandaki birÃ§ok bilgiyi internetten araÅŸtÄ±rarak edindiÄŸim iÃ§in muhtemel bilgi yanlÄ±ÅŸlÄ±klarÄ± olabilir.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="37e3add8-a1be-47ca-a8d1-8b273d400394"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%">HatalÄ± olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼nÃ¼z yerleri lÃ¼tfen yorum olarak bana bildirin.</div></figure><h2 id="b843c0b9-b4c4-4cf2-8b02-32b4b50f06c8" class="">Hafta 1</h2><hr id="1563e4dc-9b4b-49ba-8a08-ad5ba8086e0a"/><pre id="f0d1227d-36d4-485a-9d92-41573f4f3e85" class="code"><code>Neden Assembly?

- ProgramlamayÄ± daha iyi anlamak

- DiÄŸer yÃ¼ksek seviyeli dillerle yapamayacaÄŸÄ±mÄ±z ÅŸeyleri yapmak

- GÃ¶mÃ¼lÃ¼ sistemleri programlamak</code></pre><pre id="c91e6f7b-5ed3-4057-be3c-a918b5d4b59a" class="code"><code>Layered Architecture (KatmanlÄ± Mimari)

- Bilgisayarlar komplikedir.
- Kompleks kÄ±sÄ±mlarÄ± gizler.
- YazÄ±lÄ±m yapan bir kiÅŸinin donanÄ±mla iÅŸi olmaz.
- Ã‡Ã¼nkÃ¼ katmanlÄ± mimari vardÄ±r ve herkes sadece iÅŸi olan yerle ilgilenir.

- Programlama dillerinin de katmanlarÄ± vardÄ±r</code></pre><pre id="7b40c620-5844-44be-87ba-9456dab13dfc" class="code"><code>Her iÅŸlemci kendi komut setine (ISA(programlama iÃ§in binary dil)) sahiptir.</code></pre><figure id="3dae22fa-c891-4ed7-9b38-fe8c1f05b6fb" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182111.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182111.png"/></a></figure><figure id="0395764a-0ff5-4f84-81f8-3c2f904786bb" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182329.png"><img style="width:757px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182329.png"/></a></figure><figure id="76585215-a2cb-4384-b2b2-c56cf1c03841" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182421.png"><img style="width:752px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182421.png"/></a></figure><figure id="76d26778-08ea-4627-9278-a4fae68fe551" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182111%201.png"><img style="width:750px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_182111%201.png"/></a></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0b4656a2-0a84-43ee-82a0-116ce099c47c"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%"><mark class="highlight-purple_background"><em><strong>Buradaki Key Concepts gÃ¶rseli Ã§ok Ã¶nemli.</strong></em></mark></div></figure><pre id="ed51c164-941e-47fb-94a1-bb5a9c036187" class="code"><code>Assembly aslÄ±nda(MASM(Microsoft Assembler)) yÃ¼rÃ¼tÃ¼lebilir bir program oluÅŸturmaz

YÃ¼rÃ¼tÃ¼lebilir bir program iÃ§in 4 aÅŸama gereklidir:
	- Assembling: kod binary formata(makine diline) Ã§evrilir.
	- Linking:baÅŸka bir kÃ¼tÃ¼phanedeki fonksiyonlarÄ± Ã§aÄŸÄ±rÄ±nca linking gerÃ§ekleÅŸir.
		Kodda bir sÄ±nÄ±f(class) varsa da linking gerÃ§ekleÅŸir. Bu aÅŸama bu link edilmiÅŸ
		dosyalarÄ±n isimerini Ã§Ã¶zer ve asm kodu ile birleÅŸtirir ve binary formata Ã§evrilir.
	- Loading: Program memory&#x27;e yÃ¼klenir.
	- Execution: Program Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

Ã–rneÄŸin bir programÄ±mÄ±z olsun. Ve bu uygulamaya Ã§ift tÄ±klayÄ±p aÃ§mak isteyelim.
Uygulamaya her tÄ±kladÄ±ÄŸÄ±mÄ±zda &#x27;assembling&#x27; ve &#x27;linking&#x27; gerÃ§ekleÅŸmez. Onlar zaten
bir kez yapÄ±lmÄ±ÅŸtÄ±r uygulama derlenirken.

Ancak hoca Ã§alÄ±ÅŸtÄ±rma derken, compile tuÅŸuna basmaktan bahsediyor. Yani bu
Ã§alÄ±ÅŸtÄ±rmaya, linking ve assembling de dahil. BÃ¶yle yapmazsak hoca puan vermez.

Ancak uygulamaya her tÄ±kladÄ±ÄŸÄ±mzda &#x27;loading&#x27; olur Ã§Ã¼nkÃ¼ uygulamanÄ±n komutlarÄ±
belleÄŸe yÃ¼klenir. Execution aÅŸamasÄ± da gerÃ§ekleÅŸip uygulama Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.</code></pre><pre id="9843e225-ecec-406f-bd6e-2c6fb7779d68" class="code"><code>mnemonic: Ã‡alÄ±ÅŸtÄ±rma sÄ±rasÄ± gelen satÄ±rdaki komutlarÄ±n opcode&#x27;larÄ±na bu isim verilir.
					Mov, add, sub...

Genelde her mnemonic, bir CPU instruction&#x27;una denk gelir.

Her mnemonic iÃ§in ayrÄ± iÅŸlemci devreleri vardÄ±r.</code></pre><pre id="e8002cdd-c7f5-4e10-b090-d50784eb728f" class="code"><code>Hafta 7&#x27;de ayrÄ±ntÄ±lÄ± olarak gÃ¶rÃ¼lecek olan CISC ve RISC mimarileri vardÄ±r.
RISC ve CISC birer komut mimarisidir.
Intel, CISC yaklaÅŸÄ±mÄ±nÄ± kullanÄ±r.
CISC(Complex instruction set computing): Ã‡ok sayÄ±da gÃ¼Ã§lÃ¼ ve ve kompleks CPU
instruction&#x27;larÄ±(devreleri) vardÄ±r
CPU&#x27;nun instruction&#x27;u CPU devresine denk gelir.
Ã‡Ã¼nkÃ¼ CPU instruction&#x27;larÄ±, kendisine var olan devrelerle yapar.</code></pre><pre id="63c140cd-c1eb-4c66-b7ce-c64f448d8aab" class="code"><code>RISC(reduced instruction set computing): CISC&#x27;e kÄ±yasla az sayÄ±da
CPU instruction&#x27;u(devresi) barÄ±ndÄ±r. Ancak daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r.</code></pre><pre id="b3eddcdd-3471-46cb-8f00-2d82a456f647" class="code"><code>CPU&#x27;lar mantÄ±k kapÄ±larÄ±ndan oluÅŸur: NAND, OR, XOR, vs.

CPU&#x27;lar; transistÃ¶r ve Ã§eÅŸitli silikon cihazlar kullanÄ±larak yapÄ±lÄ±r.

Bir CPU&#x27;da milyonlarca transistÃ¶r vardÄ±r.

LOGIC(mantÄ±k), computing&#x27;in(hesaplama diyelim) temel dilidir.</code></pre><pre id="fee2e3f6-e18d-4e6c-8611-47532f3dd556" class="code"><code>Bilgisayarlar binary verilerle Ã§alÄ±ÅŸÄ±r. Bazen decimal, hexadecimal,
octal vs olarak da gÃ¶sterilir.</code></pre><pre id="92278aad-3661-4b73-ac3d-d08ffb506d80" class="code"><code>LSB(least significant bit) biti, binary gÃ¶sterimin en saÄŸÄ±ndaki yani en kÃ¼Ã§Ã¼k deÄŸere
sahip (2 Ã¼ssÃ¼ 0) bittir. 

MSB(most significant bit) biti, binary gÃ¶sterimin en solundaki yani en bÃ¼yÃ¼k deÄŸere
sahip(2 Ã¼ssÃ¼ N) bittir.</code></pre><figure id="b0cbff94-8b76-4a40-a082-f5abebf190bd" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_194959.png"><img style="width:744px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_194959.png"/></a></figure><pre id="735b09c2-f6a1-4914-b4ff-25204f65b419" class="code"><code>Her ne kadar Integer Storage Sizes dese de String, float deÄŸerleri de yukarÄ±daki tipler
ile(uygun olanlarla ve sÄ±ÄŸarsa) tanÄ±mlanÄ±r.</code></pre><h2 id="6cd0a471-03b9-4daf-abe0-324b20bb9b6a" class="">Hafta 2</h2><pre id="eecd06f7-6882-4b9d-a513-d02e9237906f" class="code"><code>- Clock, CPU iÅŸlemlerini senkronize eder.
- CU(Control Unit) Ã§alÄ±ÅŸtÄ±rma adÄ±mlarÄ±nÄ± koordine eder. Ä°ÅŸlemcinin kontrolcÃ¼sÃ¼dÃ¼r.
	Ä°ÅŸlemciye giren ve Ã§Ä±kan her ÅŸey buradan geÃ§er.
- ALU, aritmetik ve mantÄ±ksal iÅŸlemleri yapar.</code></pre><figure id="b70f401a-c0da-472b-87f0-37d05f42e0b3" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_215746.png"><img style="width:672px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_215746.png"/></a></figure><pre id="5b2b0906-cf6a-4993-835e-4d0a5a37f060" class="code"><code>Clock

TÃ¼m CPU&#x27;yu senkronize eden, zaman ve hÄ±z iÅŸlemlerini halleden bileÅŸendir.
Clock, tek bir instruction&#x27;un(komutun) iÅŸlenme sÃ¼residir.

wait state: Komutlar bazen belleÄŸe eriÅŸim gerektirir. Bu sÃ¼rede CPU boÅŸa dÃ¼ÅŸer.
Ã‡Ã¼nkÃ¼ herhangi yapacaÄŸÄ± bir iÅŸ yoktur. HafÄ±zadan veri gelmesini beklemektedir.
DeÄŸiÅŸkenin deÄŸeri yoktur okurken mesela. DeÄŸiÅŸkeni hafÄ±zadan getirene kadar CPU bekler.</code></pre><figure id="60bcfc10-4db4-49ab-bf4a-18b9cf41f49f" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_224148.png"><img style="width:777px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_224148.png"/></a></figure><pre id="250d2d50-de1f-441b-bed9-085d18033a03" class="code"><code>KomutlarÄ±n iÅŸlenme sÃ¼reci:

- Fetch: Bellekten komutun Ã§ekilmesidir. Ã‡Ã¼nkÃ¼ komutlar da bellekte tutulur.
- Decode: Bellekten gelen komutlarÄ± decode eder(Ã§Ã¶zer). Analiz eder, parÃ§alarÄ±na ayÄ±rÄ±r.
-	Fetch Operands: EÄŸer komutta bir deÄŸiÅŸken gerekliyse gidip hafÄ±zadan alÄ±r ve gelir.
- Execute: Control Unit&#x27;ten ALU&#x27;ya(arithmetic logic unit) aktarÄ±lan komut iÅŸlenir.
- Store output: Ãœretilen sonuÃ§ RAM&#x27;e, saklanmak Ã¼zere aktarÄ±lÄ±r.

YukarÄ±daki maddelerde her ne kadar &quot;fetch operands&quot; ve &quot;store output&quot; geÃ§se de bunlar
komut iÅŸleme dÃ¶ngÃ¼sÃ¼nden sayÄ±lmamaktadÄ±r.</code></pre><pre id="c60d86b4-a3f9-4af0-aced-eda538e9ad86" class="code"><code>Paging: ramde yer kalmazsa adreslemenin diskte devam etmesi.
Diskin bir alanÄ±nÄ±n ayrilmasina &quot;virtual memory&quot; de denir. </code></pre><pre id="b3832b54-1432-4032-953c-576cabcdfc82" class="code"><code>Reading From Memory

Multiple cycles, RAM&#x27;den bir veri okumak CPU&#x27;ya gÃ¶re Ã§ok yavaÅŸ olduÄŸu iÃ§in gereklidir.

Multiple cycle, instruction&#x27;u parÃ§alara bÃ¶ler ve her clock&#x27;ta belli parÃ§alarÄ±nÄ±
getirir. Bu yÃ¼zden bir instruction&#x27;un kaÃ§ clock&#x27;ta biteceÄŸi deÄŸiÅŸkendir.
Yani bir clock&#x27;ta birden fazla komut iÅŸleyebilir.

Single cycle ise bir clock&#x27;ta bir komut iÅŸler. Klasik fetch-decode-execute dÃ¶ngÃ¼sÃ¼</code></pre><figure id="be659d1a-473d-490d-add3-37289e797c78" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_230943.png"><img style="width:908px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_230943.png"/></a></figure><pre id="c6b45f25-5598-49d5-9018-9e9863cad8ac" class="code"><code>YukarÄ±daki gÃ¶rseli tam olarak anlayamadÄ±ÄŸÄ±m iÃ§in yorum yapamÄ±yorum ancak anladÄ±ÄŸÄ±m
kadarÄ±yla tek cycle&#x27;Ä±n sorunlarÄ±ndan bahsediyor. Ä°ÅŸlemcinin boÅŸa dÃ¼ÅŸmesine neden oluyor.
Bu yÃ¼zden Ã§oklu veri yolu kullanÄ±lÄ±yor.
Ben bÃ¶yle dÃ¼ÅŸÃ¼ndÃ¼m.</code></pre><pre id="42113eb5-1bb6-4c8d-ae90-cbd6ae758661" class="code"><code>Cache Memory

CPU ile memory arasÄ±nda bulunana ancak CPU&#x27;ya daha yakÄ±n ve oldukÃ§a hÄ±zlÄ± olan bir
statik RAM(SRAM) Ã§eÅŸididir.

Program bir kez memory&#x27;den veri okuduÄŸu zaman onu cache&#x27;a kopyalar.
Ä°kinci kez aynÄ± veriye ihtiyaÃ§ duyulduÄŸunda RAM&#x27;e gitmeden daha kolay ve hÄ±zlÄ± bir
ÅŸekilde (varsa) cache&#x27;ten alÄ±nÄ±r.

Ä°ÅŸlemci iÃ§in bir veri gerektiÄŸinde iÅŸlemci Ã¶nce cache&#x27;e gider. Bu veri cache&#x27;te var mÄ±?
diye bakar. EÄŸer varsa cache&#x27;ten alÄ±r ve gider. EÄŸer yoksa memory&#x27;e gider ve deÄŸeri
oradan okur.
EÄŸer, aranan deÄŸer cache&#x27;te varsa buna &quot;cache hit&quot;, aranan deÄŸer cache&#x27;de yoksa buna
&quot;cache miss&quot; denir.
Cache miss ve cache hit iÅŸlemcide gerÃ§ekleÅŸir.</code></pre><pre id="25165040-910d-4340-ba28-362c11509f43" class="code"><code>Multitasking

Ä°ÅŸletim sistemi aynÄ± anda birden fazla program Ã§alÄ±ÅŸtÄ±rabilir.

Bir programda Ã§oklu thread&#x27;ler ile aynÄ± anda birden fazla iÅŸlem yapÄ±labilir.

Biz bilgisayarÄ± her ne kadar, uygulamalarÄ± eÅŸzamanlÄ± olarak Ã§alÄ±ÅŸtÄ±rÄ±yor yani
tÃ¼m uygulamalar beraber aynÄ± anda Ã§alÄ±ÅŸabiliyor diye gÃ¶rsek de aslÄ±nda Ã¶yle deÄŸil.
Her programÄ±n br Ã§alÄ±ÅŸma sÃ¼resi vardÄ±r. CPU aÅŸÄ±rÄ± hÄ±zlÄ± olduÄŸu iÃ§in biz bunu farketmeyiz
CPU, her uygulamaya Ã§alÄ±ÅŸmasÄ± iÃ§in bir sÃ¼re verir. Ã–rneÄŸin der ki: A uygulamasÄ± sen,
20ms Ã§alÄ±ÅŸaksÄ±n, sonra B uygulamasÄ± sen de 20 ms Ã§alÄ±ÅŸacaksÄ±n. BÃ¶yle sÄ±ralÄ± olarak
uygulamalarÄ± Ã§alÄ±ÅŸtÄ±rÄ±r ancak dediÄŸimiz gibi CPU fazla hÄ±zlÄ± olduÄŸu iÃ§in biz bunu
farkedemeyiz.</code></pre><pre id="870a683d-9b37-46e2-a6e0-0c4b2b4a32d9" class="code"><code>Program Ã‡alÄ±ÅŸtÄ±rmada Ä°ÅŸletim Sisteminin(OS) RolÃ¼

Program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda OS ÅŸunlarÄ± yapar:
- Diskteki Ã§alÄ±ÅŸtÄ±rÄ±labilir binary formatÄ±ndaki dosyayÄ± bulur.
- Bu dosyayÄ± diskten memory&#x27;e taÅŸÄ±mak iÃ§in &quot;loader&quot;i Ã§aÄŸÄ±rÄ±r. EÄŸer gerekliyse adresleri
	Ã§Ã¶zer.
- DLL dosyalarÄ±nÄ± bulur ve baÄŸlar. (DLL,windows iÃ§in geÃ§erli)

	Ekstra bilgi: DLL, windows iÃ§in dinamik(runtime) kÃ¼tÃ¼phanelerdir.
 
Program Ã§alÄ±ÅŸÄ±rken OS ÅŸunlarÄ± yapar:
- BÃ¼tÃ¼n adresleri Ã§Ã¶zer
- BilgisayarlarÄ±mÄ±z birden Ã§ok iÅŸi aslÄ±nda sÄ±ralÄ± ama Ã§ok hÄ±zlÄ± yapardÄ±(multitasking).
	Ama Ã§ok hÄ±zlÄ± oldupu iÃ§in biz bunu farkedemezdik. Yeni aÃ§tÄ±ÄŸÄ±mÄ±z uygulamayÄ± da bu
	sÄ±raya ekler. Yani sÄ±rayla Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± uygulamalar iÃ§inde bizim aÃ§tÄ±ÄŸÄ±mÄ±z uygulama
	da eklenecek.
- IO(GiriÅŸ/Ã‡Ä±kÄ±ÅŸ) isteklerini yÃ¶netir.

Program sonlandÄ±ktan sonra OS, uygulamayÄ± bellekten temizler.</code></pre><pre id="77b6e5a2-ae00-4464-8cae-afd2fad282d9" class="code"><code>REGISTER

Registers, CPU&#x27;nun iÃ§inde yer alan aÅŸÄ±rÄ± hÄ±zlÄ± depolama alanlarÄ±dÄ±r.

Uygun memory alanÄ±na ulaÅŸmaktan daha kÄ±sa bir zamanda eriÅŸilmek iÃ§in tasarlandÄ±.

Yani bir veriyi memory&#x27;den Ã§ekmek yerine register&#x27;lere atÄ±p oradan Ã§ekebiliyoruz.</code></pre><pre id="6801d8ff-73a9-44c3-b28d-ec0a1d7b3aa6" class="code"><code>Register Tipleri

â—‹ General purpose registers
â—‹ Segment registers
â—‹ Processor status flags register
â—‹ Instruction pointer</code></pre><figure id="1a207866-10a5-4921-b60a-636ed83a256b" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_093358.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_093358.png"/></a></figure><pre id="4a9d551c-6a69-4d6e-a586-6f4b2b49851e" class="code"><code>General Purpose Registers

Ã–ncelikli olarak aritmetiksel iÅŸlemler ve veri aktarÄ±mÄ± iÃ§in kullanÄ±lÄ±r.
Bit sayÄ±larÄ±na gÃ¶re belirli isimlendirme ve tÃ¼rleri vardÄ±r.

32 bit olanlarÄ±: EAX, EBX, ECX, EDX
16 bit olanlarÄ±: AX, BX, CX, DX
8 bit olanlarÄ±(high): AH, BH, CH, DH
8 bit olanlarÄ±(low): AL, BL, CL, DL

- Farkettiyseniz harfler hep aynÄ± sadece Ã¶n ve arkalarÄ±na gelen harfler deÄŸiÅŸmiÅŸ.
	AX, AH, AL, EAX registerleri aslÄ±nda aynÄ±dÄ±r. Sadece boyutlarÄ± farklÄ±dÄ±r.
	BaÅŸÄ±na E gelirse 32 bit oluyor. YanÄ±na H/L gelirse de 8 bit oluyor. AX de 16 bit

	Ä°leride gÃ¶receÄŸimiz Ã¼zere assembly komutlarÄ±nda ax ve eax registerlerini aynÄ± register
	olarak kullanabiliyoruz. Yani tek deÄŸiÅŸen ÅŸey boyutlarÄ±

- 8 bit olanlarda high ve low yazÄ±yor.
- High: 16 bit AX registerinin en deÄŸerli yani ikiye bÃ¶lersek soldaki 8 bitine verilen
	isimdir.
- Low: 16 bit AX registerinin en deÄŸersiz yani ikiye bÃ¶lersek saÄŸdaki 8 bitine verilen
	isimdir.

Bu register tÃ¼rÃ¼ her ne kadar general purpose olsa da bazÄ±larÄ±nÄ± belli gÃ¶revler iÃ§in
kullanabiliyoruz.
Mesela ileride gÃ¶receÄŸimiz assembly LOOP&#x27;unun kaÃ§ kez dÃ¶neceÄŸini belirlemek iÃ§in
ECX registerini kullanÄ±yoruz.

Ancak Ã§oÄŸu aritmetiksel iÅŸlemde ve veri taÅŸÄ±ma iÅŸleminde AX/EAX ve BX/EBX kullanÄ±lÄ±r.

EAX = accumulator
Accumulator dendiÄŸinde, aritmetiksel iÅŸlemlerin depolanmasÄ± iÃ§in kullanÄ±lan EAX
registeri akla gelmeli

ECX = Loop Counter (dÃ¶ngÃ¼ iterasyon sayÄ±sÄ±nÄ± tutar.)</code></pre><figure id="67251345-dc3f-4f94-a64c-be6e1e8e5f1a" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_095104.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_095104.png"/></a></figure><pre id="9d6ad699-6da7-4409-9b08-15e1246a190f" class="code"><code>Segments (segment registers)

CS -&gt; Code Segment
DS -&gt; Data Segments
SS -&gt; Stack segment

Assembly&#x27;de gÃ¶receÄŸimiz mov komutunda, segment registerler&#x27;e atama iÅŸlemi yapÄ±lamaz</code></pre><pre id="e7406304-4a69-4591-bf21-1ef62aa07537" class="code"><code>Instruction Pointer(program counter)

Hafta 7&#x27;de daha ayrntÄ±lÄ± gÃ¶relecek olan program counter&#x27;Ä± tutan register&#x27;dir.
Ã‡alÄ±ÅŸtÄ±rÄ±lmmakta olan komutun adresini tutar. DiÄŸer satÄ±ra geÃ§ildiÄŸinde program counter
artar ve instruction pointer&#x27;in iÃ§eriÄŸi gÃ¼ncellenir.</code></pre><pre id="0479e5ac-5fb3-4de2-9753-fc2e0611879a" class="code"><code>EFLAGS

Flag&#x27;ler bir register tipidir.
32 bit register&#x27;lerdir. EAX gibi yani. Bu yÃ¼zden baÅŸÄ±nda &#x27;E&#x27; var.
Status ve control flag olarak ikiye ayrÄ±lÄ±r.

Bir binary bit ile ifade edilir(o kadar yer kaplar).
Yani sadece 0 ya da 1 olabilir.</code></pre><pre id="4a82479e-f1bc-4bf9-b69d-35819e12c692" class="code"><code>Status Flags

Ä°ÅŸlemcinin o anki durumu hakkÄ±nda bilgileri iÃ§erir.
Bilgi derken &#x27;evet&#x27; ya da &#x27;hayÄ±r&#x27; ÅŸeklinde yani.

En yaygÄ±n Status Flags

	- Carry: iÅŸaretsiz sayÄ±larÄ±n aritmetik iÅŸlemlerinde taÅŸma olursa flag 1 olur.

	- Overflow: iÅŸaretli sayÄ±lan aritmetik iÅŸleminde taÅŸma olursa flag 1 olur.

	- Sign: sonuÃ§ negatifse flag 1 olur.

	- Zero: SonuÃ§ sÄ±fÄ±rsa flag 1 olur.

Flag&#x27;ler ileride anlatÄ±lacaÄŸÄ± iÃ§in aÃ§madÄ±m.</code></pre><figure id="da4406ad-ff22-42da-9e77-a7ce73cee06c" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_104724.png"><img style="width:701px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_104724.png"/></a><figcaption>Ä°ÅŸaretli olanlar Ã¶nemli/nispeten Ã¶nemli olan register&#x27;lerdir.</figcaption></figure><pre id="91431529-2e03-4e38-9b9b-6605784e22e5" class="code"><code>Compatibility Mode (Uyumululuk Modu):

Uyumluluk modu, bir yazÄ±lÄ±mÄ±n daha eski bir yazÄ±lÄ±m sÃ¼rÃ¼mÃ¼nÃ¼ taklit ettiÄŸi veya eski
veya uyumsuz yazÄ±lÄ±mlarÄ±n veya dosyalarÄ±n bilgisayarÄ±n daha yeni donanÄ±mÄ± veya
yazÄ±lÄ±mÄ±yla uyumlu kalmasÄ±na izin vermek iÃ§in baÅŸka bir iÅŸletim sistemini taklit
ettiÄŸi bir yazÄ±lÄ±m mekanizmasÄ±dÄ±r.
KÄ±saca; 64 bit bir bilgisayarda 32 bit, 16 bit yazÄ±lÄ±mlarÄ± kullanamaya izin veren moddur
Ama elbette uygulamalar tam olarak verimli Ã§alÄ±ÅŸmaz. Sorunlar Ã§Ä±kabilir.


64 bit mode:

64 bit adres ve operand kullananan moddur. Åuanki gÃ¼ncel bilgisayarlar 64 bir moda
sahip</code></pre><pre id="68785425-f7f5-4cd1-a0b9-4e0b0a3baaed" class="code"><code>Ã–nemli:

IA-32 iÅŸlemciler, 32 bit register barÄ±ndÄ±rÄ±r.
4 GB adreslenebilir RAM&#x27;e sahiptir.
Paging(virtual memory) yapÄ±labilir.</code></pre><pre id="512f1103-2cdd-413d-870e-db4437410603" class="code"><code>BazÄ± Teknolojiler(Ã¶nemli)

	Pipeline: TalimatlarÄ±n eÅŸ zamanlÄ± olarak yÃ¼rÃ¼tÃ¼lmesi.
	Fetch-decode-execute dÃ¶ngÃ¼sÃ¼nÃ¼ gerÃ§ekleÅŸtiren hiÃ§bir CPU bÃ¶lÃ¼mÃ¼nÃ¼n boÅŸ kalmamasÄ±.
	Hep bir iÅŸ yapmasÄ±. Pipeline olmadan; Fetch, komutlarÄ± Ã§eker ve komutlar iÅŸlenip
	cevap verilene kadar bekler. Ancak pipeline ile; fetch aÅŸamasÄ± bittikten ve komut
	decode aÅŸamasÄ±na geÃ§tikten sonra diÄŸer komut iÃ§in fetch aÅŸamsaÄ± baÅŸlar. Ã–nceki komutun
	tamamen bitmesini beklemez. BÃ¶ylece fetch iÅŸlemini yapan kÄ±sÄ±m asla boÅŸ kalmaz.

	SuperScalar: CPU&#x27;nun bir clock cycle&#x27;da birden fazla instruction Ã§alÄ±ÅŸtÄ±rabilmesidir.
	Yani komut dÃ¼zeyinde paralelizm gerÃ§ekleÅŸtirir. Bir instruction iÅŸlenirken, komut
	iÅŸlenme dÃ¶ngÃ¼sÃ¼nÃ¼n(fetch-decode-execute) baÅŸÄ±na giden bir dizi metot tanÄ±mlar.
	Yani bir clock&#x27;ta birden fazla instruction iÃ§in output verir.
	KÄ±saca, aynÄ± clockta birden fazla komut Ã§alÄ±ÅŸtÄ±rabilen teknolojidir.

	HyperThreading: Bir iÅŸlemcide aynÄ± anda iki iÅŸlemin yapÄ±lmasÄ±dÄ±r.
	Bir core olmasÄ±na raÄŸmen (yazÄ±lÄ±msal olarak) sanki iki core varmÄ±ÅŸ gibi davranmasÄ±dÄ±r.
	Bu mimaride register sayÄ±sÄ± ikiye katlanÄ±r.
	Register ikiye katlandÄ±ÄŸÄ± iÃ§in iki core varmÄ±ÅŸ gibi davranÄ±r zaten.
  Bu, islemci gucunun ikiye katlandÄ±ÄŸÄ± anlamina gelmez.
  Basit islerle bir core&#x27;un tamamÄ±nÄ±n ilgilenmesi yerine bir core&#x27;u
  iki sanal core&#x27;a bolerek bir core&#x27;in birden fazla is yapmasini ve 
  core&#x27;un tam kapasitesini kullanmayÄ± saÄŸlar.

	Dual-core Processing: AynÄ± IC paketinin iÃ§indeki iki iÅŸlemcidir.
	Her iÅŸlemcinin kendine ait kaynaklarÄ±(cache&#x27;si ve controller&#x27;i) vardÄ±r.
	IC paketi: DonanÄ±msal bir parÃ§a. Ä°ki core&#x27;u birleÅŸtiren bir Ã§atÄ± gibi bir ÅŸey.
	Ä°nternetten gÃ¶rseline bakabilirsiniz.

	Bunlar, benim internetten araÅŸtÄ±rarak Ã¶ÄŸrendiklerim ve anladÄ±klarÄ±m.</code></pre><pre id="ca55defd-79f2-4b25-945c-9f7047695f47" class="code"><code>CISC &amp; RISC Mimarisi Hafta-7&#x27;de ayrÄ±ntÄ±lÄ± olarak iÅŸlendiÄŸi iÃ§in ÅŸimdi aÃ§Ä±klamayacaÄŸÄ±m.</code></pre><pre id="60cc9087-4e96-4e13-b0aa-4073f3b3fcbd" class="code"><code>X86 Ä°ÅŸlemcide HafÄ±za YÃ¶ntetimi

Protected Mode:
	Windows, Linux gibi iÅŸletim sistemleri bu mod ile Ã§alÄ±ÅŸÄ±r.
	Programlar, segment adÄ± verilen ayrÄ± bir bellek bÃ¶lgesinde Ã§alÄ±ÅŸÄ±r.
	Ä°ÅŸlemci, programlarÄ±n hafÄ±zada kendisine atanan segment dÄ±ÅŸÄ±nda yer kullanmasÄ±na
	izin vermez.

Real Adress Mode:
	MS-DOS bu modu kullanmaktadÄ±r.
	Sistem hafÄ±zasÄ±na ve belleÄŸe direk eriÅŸimi vardÄ±r. Ä°ÅŸletim sisteminin Ã§Ã¶kmesine
	sebep olabilir.

System management mode:
	Power management, system security, diagnostics... gibi sistemin ihtiyaÃ§ duyduÄŸu
	ÅŸeyler bu moda sahiptir.

Bizim bilgisayarlarÄ±mÄ±zda Ã¼Ã§ mod da bulunur. Bilgisayar kullanÄ±rken ÅŸarjÄ± gÃ¶rebiliyoruz,
sistem gÃ¼venliÄŸi saÄŸlanÄ±r, tarih gÃ¶sterilir...
System management mod iÃ§in arkaplanda Ã§alÄ±ÅŸan Ã¶zellikler diyebiliriz.
Nam-Ä± diÄŸeri ile CMD(command line/komut ekranÄ±) aÃ§tÄ±ÄŸÄ±mÄ±zda karÅŸÄ±mÄ±za gelen siyah
ekran, real address mode&#x27;dur. Bu ekrandan sistem yÃ¶netimi de saÄŸlayabiliriz
Protected mode ise kullanÄ±cÄ±nÄ±n normal bir ÅŸekilde uygulamalarÄ± kullandÄ±ÄŸÄ± mod&#x27;dur.</code></pre><pre id="1286541a-b7d6-4bc0-8a3f-d34a7615377b" class="code"><code>Virtual 8086 mode

Protected mode&#x27;un Ã¶zel bir versiyonudur.
Her program kendi 8086 bilgisayarÄ±na sahiptir.
KÄ±sacasÄ± 8086, CPU&#x27;nun(CPU korumalu modda olur) real mode&#x27;a sahip bir uygulamayÄ±
Ã§alÄ±ÅŸtÄ±rmasÄ±dÄ±r. Ã–rneÄŸin &quot;cmd&quot; komutu</code></pre><pre id="d1b14644-e4eb-4cd3-b7cc-9c3d6025a596" class="code"><code>Addressable Memory (adreslenebilir RAM) (X86 iÃ§in)

Protected Mode:
	En fazla 4 GB memory segment ayrÄ±labilir.
	32 bit adresleme vardÄ±r.

Real Mode Address ve 8086 mode:
	1 MB hafÄ±za alanÄ±na sahiptir.
	20- bit adresleme vardÄ±r.</code></pre><pre id="eb75f3ef-0298-4bdf-b5a4-e5fa7721a283" class="code"><code>Real Address Mode

En fazla 1 MB adreslenebilir RAM saÄŸlar.
Uygulamalar, herhangi bir adres bÃ¶lgesine eriÅŸebilir.
Single tasking(AynÄ± anda birden fazla program Ã§alÄ±ÅŸamaz.)
MS-DOS iÅŸletim sistemi tarafÄ±ndan desteklenir.
1 MB = 2Ã¼ssÃ¼ 20 bit. Bu yÃ¼zden 20-bit adresleme denir.
16 bit register vardÄ±r.</code></pre><pre id="2c5db876-b620-488d-94e4-da36ffacb95e" class="code"><code>Segmented Memory

8086 mikroiÅŸlemcisi, kendisine verilen 1 MB belleÄŸin tamamÄ±nÄ± direk kullanmaz.
Belli bÃ¶lÃ¼mlere(segmentler) ayÄ±rÄ±r. Bu segmentlerin belli gÃ¶revleri vardÄ±r.
16 tane 64 KB&#x27;lÄ±k segmentlere ayÄ±rÄ±r.

AÅŸaÄŸÄ±daki gÃ¶rselde ise aynÄ± tanÄ±m olmasÄ±na raÄŸmen Ã¼Ã§ Ã§eÅŸit segment olduÄŸunu sÃ¶ylÃ¼yor

Bana kalÄ±rsa burada hocanÄ±n tanÄ±mÄ±nÄ± baz alalÄ±m. Ancak data, code ve stack
segmentlerini bilmek gerekiyor. Ki ileride de bu segmentleri gÃ¶receÄŸiz ancak adlarÄ±
program segmentleri olarak geÃ§iyor.. Benim kafamÄ± karÄ±ÅŸtÄ±ran kÄ±sÄ±m iÅŸte bu.
Neyse, bence yine  aÅŸaÄŸÄ±daki gÃ¶rseldekileri bilelim. Segment lafÄ± geÃ§erse
aÅŸaÄŸÄ±dakileri bilelim :)</code></pre><figure id="6d3c91b0-316f-4899-b7bf-decb62696239" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/memorysegments.png"><img style="width:734px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/memorysegments.png"/></a></figure><pre id="4045f0df-d565-45cf-945c-75fd200972cc" class="code"><code>Program Segmentleri

Adres gÃ¶sterimi iÃ§in her zaman HEXADECIMAL format kullanÄ±lÄ±r.

// Benim program segmentinden anladÄ±ÄŸÄ±m ÅŸey ÅŸu: Assembly kodunu .data, .code, .stack
// notasyonlarÄ±nÄ±n altÄ±na yazÄ±yoruz. Bu aslÄ±nda, kodlarÄ±n hangi bellek bÃ¶lgesine
// yerleÅŸeceÄŸini sÃ¶ylÃ¼yor. Yani program segmentleri memory segmentlerine referans
// veriyor. Bu yÃ¼zden memory ve program segmentlerinin isimleri aynÄ±.

Bir programÄ±n Ã¼Ã§ tÃ¼r segmenti vardÄ±r: code, data, and stack(YukarÄ±daki gÃ¶rseldeki gibi)

ÃœÃ§ tane temel segment registeri vardÄ±r ve bunlar segmentlerin baÅŸlangÄ±Ã§ adreslerini
tutar: CS(code segment), DS(Data segment), SS(Stack segment)</code></pre><figure id="596a4136-6364-40db-8ed2-25f53defacd6" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_141922.png"><img style="width:736px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_141922.png"/></a></figure><pre id="9842fb35-173a-434c-83fe-6f3d46d35200" class="code"><code>Protected Mode

4 GB adreslenebilir RAM&#x27;e sahiptir (00000000h to FFFFFFFFh)
// Bu miktar gÃ¶zÃ¼me Ã§ok az geldi. 32 GB bellekte de mi 4 gb yoksa bu sadece
// X86 iÅŸlemciler iÃ§in mi geÃ§erlidir bilmiyorum.

Her program, protected memory bÃ¶lÃ¼mÃ¼ne atanÄ±r.

Multitasking iÃ§in dizayn edilmiÅŸtir.

Memory tipleri:
	Flat Segment Model
	Multi Segment Model: Hoca Ã¶nemsemediÄŸi ve ilgilenmeyeeceÄŸi iÃ§in ben de yazmadÄ±m.
	Paging

MASM(microsofr assembler) programlarÄ± Flat memory modelini kullanÄ±r.</code></pre><pre id="8da21bb1-b736-4741-b2c8-f350d1764164" class="code"><code>Flat Segment Model

Tek Bir GDT(Global Descriptor Table) vardÄ±r ve OS tarafÄ±ndan yÃ¶netilip kullanÄ±lÄ±r.
Bellek, programa tek bir bitiÅŸik bellek alanÄ± olarak gÃ¶zÃ¼kÃ¼r.
YAni her programÄ±n ayrÄ± bir bellek bÃ¶lgesi yoktur.
GDT: Bir programÄ±n, Ã§alÄ±ÅŸma esnasÄ±nda hangi segmentleri kullandÄ±ÄŸÄ±nÄ±, hangi segmente
okuyup yazma yapabileceÄŸini, programÄ±n baÅŸlangÄ±Ã§ adresini, boyutu tutan bir tablodur.</code></pre><pre id="f17fea2c-e6ea-40ad-b451-aa904be9bc21" class="code"><code>Paging

RAM&#x27;de yer kalmayÄ±nca sabit diskin bir bÃ¶lÃ¼mÃ¼nÃ¼ RAM olarak kullanmaktÄ±r.
Virtual Memory = Paging

- Direk olarak CPU tarafÄ±ndan desteklenir.
- Her segmenti, boyutu 4KB(4096 byte) olan bloklara bÃ¶ler.
- TÃ¼m programlarÄ±n toplamÄ± belleÄŸin boyutundan daha bÃ¼yÃ¼k olabilir
- HafÄ±zada Ã§alÄ±ÅŸmakta olan programÄ±n bir bÃ¶lÃ¼mÃ¼dÃ¼r.

Virtual memory manager: OS, pages(her bir blok)in load ve unload iÅŸlerini yÃ¶netir. 

Page fault: Diskten bir page yÃ¼klemeye Ã§alÄ±ÅŸÄ±rken CPU tarafÄ±nda verilen hatadÄ±r.
Sebebini ben de bilmiyorum :)</code></pre><pre id="5a169861-a75c-4fe3-bffd-72b4f3147b76" class="code"><code>Levels of Input/ Output

Level 3- YÃ¼ksek seviyeli Diller: TaÅŸÄ±nabilir, kullanÄ±ÅŸlÄ± ama her zaman hÄ±zlÄ± deÄŸil
-&gt; C, Java,...........
// C, yÃ¼ksek seviyeli dil deÄŸil ki diyebilirsiniz ama ders, neredeyse tamamen donanÄ±mla
// ilgili oldÄŸu iÃ§in assembly&#x27;e gÃ¶re bÃ¼tÃ¼n diller yÃ¼ksek seviye kalÄ±yor. Bu ders iÃ§in
// bÃ¶yle :D

Level 2- Operating system:
GeniÅŸ yetenekleri vardÄ±r.
Uzman olmak iÃ§in bilecek Ã§ok ayrÄ±ntÄ± gerektirir.

Level 1- BIOS(Basic Input - Output System):
SÃ¼rÃ¼cÃ¼lerin direk cihazlarla iletiÅŸim kurmasÄ±nÄ± saÄŸlar.
Bilgisayarda hangi iÅŸletim sistemi varsa aÃ§Ä±lÄ±ÅŸta onun Ã§alÄ±ÅŸtÄ±rma dosyasÄ±nÄ± aÃ§ar
ve iÅŸletim sistemi aÃ§Ä±lÄ±r.
OS&#x27;in gÃ¼venliÄŸi bu katmanda kullanÄ±cÄ± programÄ± yazÄ±lmasÄ±na izin vermeyebilir. </code></pre><pre id="0afedcea-f6db-4aa5-8da1-081057cad8b2" class="code"><code>Programlama Seviyeleri

Assembly dili aÅŸaÄŸÄ±daki bÃ¼tÃ¼n seviyelerde input-output saÄŸlayabilir.
Yani bÃ¼tÃ¼n katmanlar iÃ§in kod yazÄ±labilir.
KÃ¼tÃ¼phane, OS fonksiyonlarÄ±, BIOS Ã¶zellikleri, donanÄ±m kodlar yazÄ±labilir.</code></pre><figure id="e348c710-68a3-471a-9f4e-07b5aaae269a" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_150240.png"><img style="width:672px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-27_150240.png"/></a></figure><p id="eca6238e-a38c-49df-9a7e-e30444ec0f9e" class="">
</p><h2 id="97f59aaa-72d0-4335-9ed4-81a945dfc4b6" class="">Hafta 3 ve 4 (Temel Bilinmesi Gerekenler)</h2><hr id="a61b1195-cf84-4bf9-bb24-53f06b30786d"/><figure id="ce5152bc-deaa-424d-91ff-5cc8d29ce945" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/binto_hex.png"><img style="width:726px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/binto_hex.png"/></a></figure><figure id="028ce292-73f1-4e0e-9a60-eb7221e6f880" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/binath.png"><img style="width:744px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/binath.png"/></a></figure><figure id="522c58e4-6587-424b-9eab-35ddb7e2650c" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/negbinath.png"><img style="width:739px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/negbinath.png"/></a></figure><hr id="a01005d1-2011-4c9a-a42b-35ce5448c3e1"/><h3 id="a1e00e48-37b1-4ea1-9c1d-e166f0d66cd5" class="">Hocadan pek anlamadÄ±ÄŸÄ±m yerler (Teorik)</h3><hr id="ae86fc1c-9520-41f3-bfd1-def5b9437bc2"/><figure id="29741abe-3a4d-4c27-a036-9b54f4e973d4" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/addressingmemory.png"><img style="width:742px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/addressingmemory.png"/></a><figcaption>Little Endian Order iÅŸte budur. DÃ¶kÃ¼manÄ±n ileriki kÄ±sÄ±mlarÄ±nda buna bir daha deÄŸinilecek.</figcaption></figure><figure id="dd9921fc-49b5-4472-8b11-da6ab62eb366" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/syntax.png"><img style="width:743px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/syntax.png"/></a></figure><figure id="a24ac3bf-db78-49b8-a7da-243097b4b7fd" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/registers-intro.png"><img style="width:737px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/registers-intro.png"/></a></figure><figure id="be7eedd2-ce09-4fd2-9136-79110b35ed32" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/dataregisters.png"><img style="width:739px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/dataregisters.png"/></a></figure><figure id="f5da9bc1-34d3-423e-a9db-da65d50a20fa" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/registers.png"><img style="width:1683px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/registers.png"/></a></figure><figure id="dd2c1a40-5e3a-4085-9af5-79f594ff7bed" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/flasgs.png"><img style="width:740px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/flasgs.png"/></a><figcaption>Control Registers = Flags</figcaption></figure><figure id="b9da5306-8883-45a8-9278-7b2a1775cae9" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/addressing_modes.png"><img style="width:733px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/addressing_modes.png"/></a></figure><figure id="e68fc058-a1c8-4928-9a54-3ae13623ff5d" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/regs.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/regs.png"/></a></figure><figure id="22bbee66-3789-487f-af8c-106782ce03cd" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/tipler.png"><img style="width:728px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/tipler.png"/></a></figure><hr id="6adcab52-6add-4f7f-bd37-29e7c16fc6a6"/><h3 id="bfc3089b-6072-4b46-9924-eef79e2225b8" class="">Teori ve giriÅŸ kÄ±smÄ± bitti</h3><hr id="cacdb16c-bb46-48f8-a3a7-94be0a424293"/><h3 id="aa1acf1b-b0d8-4b33-a15e-497f29d68e48" class="">Åimdi Assembly ve komutlarÄ±na giriÅŸ yapÄ±yoruz</h3><figure id="e0d17e8f-37e0-42e6-b23a-42b9e444ce28" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/comments.png"><img style="width:731px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/comments.png"/></a></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="2395c0fe-59a1-4a2d-92e2-0f0e190b1d2c"><div style="font-size:1.5em"><span class="icon">ğŸ’¡</span></div><div style="width:100%"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>ASSEMBLY KOMUTLARI ve ayrÄ±lmÄ±ÅŸ kelimeler BÃœYÃœK KÃœÃ‡ÃœK HARF DUYARSIZDIR.
</strong></em></span></mark><mark class="highlight-yellow"><span style="border-bottom:0.05em solid"><em><strong>MOV </strong></em></span></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>Ä°LE </strong></em></span></mark><mark class="highlight-yellow"><span style="border-bottom:0.05em solid"><em><strong>mov</strong></em></span></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong> arasÄ±nda, </strong></em></span></mark><mark class="highlight-yellow"><span style="border-bottom:0.05em solid"><em><strong>BYTE </strong></em></span></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>ile </strong></em></span></mark><mark class="highlight-yellow"><span style="border-bottom:0.05em solid"><em><strong>byte </strong></em></span></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>arasÄ±nda bir fark yoktur.</strong></em></span></mark></div></figure><pre id="155b1aac-742a-49bc-9627-cafd9d58cdd7" class="code"><code>Mov Instruction

mov destination source	

- Mov instruction, atama iÅŸlemi yapmamÄ±zÄ± saÄŸlar.
- Atama iÅŸleminde atanan deÄŸerde deÄŸiÅŸiklik olmaz. Mesela C&#x27;de, a deÄŸiÅŸkenine 5 sayÄ±sÄ±nÄ±
	atarken nasÄ±l 5(atanan) sayÄ±sÄ± deÄŸiÅŸmiyorsa burada da source(kaynak/atanan) deÄŸiÅŸmez
- Operandlar ÅŸÃ¶yle olabilir:
		mov reg reg -&gt; registerdan registere atama
		mov mem reg -&gt; registerden memory&#x27;e atama
		mov reg mem -&gt; memeory&#x27;den registere ataa
		mov reg imm -&gt; immediate(integer, string, const deÄŸer) deÄŸeri registere atama
		mov mem imm -&gt; immediate deÄŸeri memory&#x27;e atama 
- Ä°ki operand da aynÄ± boyutta olmalÄ±dÄ±r.
- Segment registerine immediate veri aktarÄ±lamaz.
- DS(data seg.), CS(code seg.), SS(stack seg.) segment registerlerden bazÄ±larÄ±dÄ±r.
	YukarÄ±da gÃ¶rmÃ¼ÅŸtÃ¼k.
- AynÄ± instruction&#x27;da birden fazla memory operandÄ± olamaz. Bu sadece mov iÃ§in geÃ§erli
  deÄŸildir. Hibir komutta birden fazla memory olamaz.
- Memory dediÄŸimiz ÅŸey bildiÄŸimiz deÄŸiÅŸken yani.
- Yani memory&#x27;den memory&#x27;e veri aktarÄ±lamaz.
- Memory&#x27;den memory&#x27;e aktarÄ±m yapmak ÅŸÃ¶yle olur:

.code
mov ax,var1
mov var2,ax
// kaynak Ã¶nce ax register&#x27;ine aktarÄ±lÄ±r. DiÄŸer satÄ±rda da register&#x27;den diÄŸer memory&#x27;e
// aktarÄ±lÄ±r.</code></pre><pre id="1f1687a0-4dfc-46e3-bc28-7784931d1de4" class="code"><code>immediate: integer olan const ifadeleri ifade eder. Ã–r: 55,20,100</code></pre><pre id="443db6bb-cb07-420b-89b9-0603d188cd26" class="code"><code>int a = 5;
// bu, atama iÅŸleminin C&#x27;deki halidir.
// 5, immediate bir deÄŸerdir. &#x27;a&#x27; ise memory&#x27;dir.
// Biz burada memory&#x27;e immediate deÄŸer atadÄ±k.</code></pre><pre id="cda790e1-7f34-4311-b6d8-a9eb17811050" class="code"><code>Ekleme ve Ã‡Ä±karma Ä°ÅŸlemi

mov eax, 1000h; burada sadece register&#x27;a sabit sayÄ± atadÄ±k.
add eax, 3000h;
// eax registerindeki sayÄ± ile 3000h sayÄ±sÄ±nÄ± toplar ve eax registerine atar.
sub eax, 2000h;
// eax registerindeki sayÄ±dan 2000h sayÄ±sÄ±nÄ± Ã§Ä±karÄ±r ve deÄŸeri eax registerine atar.</code></pre><pre id="8f81dd07-ca2a-43a5-8b4d-e3eff92f7c42" class="code"><code>DeÄŸiÅŸken TanÄ±mlama

var1 byte &#x27;A&#x27;
var2 byte 0
var3 byte 255
var4 sbyte -128 // iÅŸaretli olduÄŸu iÃ§in max. -128 alabilir.
var5 sbyte +127 // iÅŸaretli olduÄŸu iÃ§in max 127 olabilir
var6 sbyte ? ; uninitialized variable: deÄŸeri atanmamÄ±ÅŸlar ? ile gÃ¶sterilir.

// EÄŸer var1&#x27;in adresi 0000 ise var2&#x27;nin adresi 0001 olur.
// Ã‡Ã¼nkÃ¼ byte tipi hafÄ±zada 1 byte kaplar. Bu yÃ¼zden adres 1 artar.
// HafÄ±zada hemen arkasÄ±na yerleÅŸir.
// Byte tipi sadece boyutu belirtir. Yani bu 1 byte&#x27;Ä±n yani 8 bitin iÃ§ine herhangi
// bir veri tipi yazabilirsiniz.(tabi sÄ±ÄŸarsa :)),</code></pre><pre id="8e22e223-3540-41bb-bdec-35051c1be649" class="code"><code>
Arrays (Diziler)

list1 BYTE 10,20,30,40
// Bir deÄŸiÅŸken 1&#x27;den fazla deÄŸer alÄ±yorsa bu bir dizidir.
// list1 adÄ±nda tipi Byte olan ve 10,20,30,40 deÄŸerlerinden oluÅŸan bir dizi tanÄ±mlandÄ±

list2 BYTE 10,20,30,40
      BYTE 50,60,70,80
      BYTE 81,82,83,84
// Arraylar, hafÄ±zada ard arda dizilmiÅŸ hafÄ±za alanlarÄ±dÄ±r.
// Sonraki elemana ulaÅŸmak iÃ§in baÅŸlangÄ±Ã§ adresine, kaÃ§Ä±ncÄ± adrese ulaÅŸmak istediÄŸimiz
// bilgisi eklenir. Yani her index bir byte&#x27;dÄ±r. Ä°leride zaten bunun Ã¶rnekleri var
// ancak Ã¶rneÄŸin;
// mov al, [list2+4]; dizinin baÅŸlangÄ±Ã§ adresine 4 byte ekleyecek. O da 50 elemanÄ± olur.
// EÄŸer dizinin tipi WORD(2byte) olsaydÄ± 4/2(veri tipi) = 2. Dizinin 2. elamanÄ±na
// gidecekti

list3 BYTE ?,32,41h,00100010b
// Ä°lk deÄŸeri null olan, 4 elemandan oluÅŸan bir dizi

list4 BYTE 0Ah,20h,â€˜Aâ€™,22h
// ElemanlarÄ±n string, int olup olmamasÄ± bizi ilgilendirmez. Bir byte&#x27;i geÃ§memeleri
// bizim iÃ§in yeterlidir.</code></pre><pre id="0e9df71b-2f4a-4a26-88e5-e87a3c9ee89b" class="code"><code>Strings

// String&#x27;ler sÄ±ralÄ± byte karakterleridir.

str1 BYTE &quot;Enter your name: &quot;,0
// str1 deÄŸiÅŸkenine &quot;Enter your name:&quot; string&#x27;ini atar.
// String&#x27;in tipi byte Ã§Ã¼nkÃ¼ her harf bir byte&#x27;dir. String&#x27;ler de byte dizileridir.
// String&#x27;in bittiÄŸini gÃ¶stermek iÃ§in string sonuna virgÃ¼l ve 0 atÄ±lÄ±r.

str2 BYTE &#x27;ERROR!&#x27;,0Dh,0Ah,&#x27;Halting programâ€˜,0Dh,0Ah,0
// &quot;Error&quot; yazar, stringi bitirir. Bir satÄ±r aÅŸaÄŸÄ±ya iner. &quot;Halting program&quot; yazar,
// stringi bitirir. Bir satÄ±r aÅŸaÄŸÄ±ya iner ve komutu bitirir.
// 0Dh -&gt; Return karakteri anlamÄ±na gelir. Ã–ncesinde gelen stringin bittiÄŸini belirtir. 
// 0Ah -&gt; Yeni satÄ±r anlamÄ±na gelir. Bir satÄ±r aÅŸaÄŸÄ±ya iner.

str3 BYTE &#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;
// Byte tipinde bir dizi oluÅŸturur. String de byte dizisi olduÄŸu iÃ§in
// bununla farkÄ± yoktur. Ancak direk String olarak deÄŸerlendirilmediÄŸi iÃ§in
// satÄ±r sonuna 0 koymaya gerek yok.

newLine BYTE 0Dh,0Ah,0
// BoÅŸ ekranda &#x27;enter&#x27;a basar, aÅŸaÄŸÄ±ya iner ve satÄ±r biter.

greet BYTE &quot;A string in&quot;
      BYTE &quot; two parts.&quot;,0
// Birden Ã§ok satÄ±rda string yazÄ±labilir. Ä°lk satÄ±rdan sonra 0A yazmaya gerek yok Ã§Ã¼nkÃ¼
// string zaten bitiÅŸik. alt alta da olsa string bitiÅŸik yazÄ±lacak ve 0 ile de bitecek.

menu BYTE &quot;1. Create a new account&quot;,0dh,0ah,
&quot;2. Open an existing account&quot;,0dh,0ah,
&quot;3. Exit&quot;,0ah,0ah,
&quot;Choice&gt; &quot;,0
// &quot;1. Create a new account&quot; yazar aÅŸaÄŸÄ±ya iner, &quot;2. Open an existing account&quot; yazar,
// aÅŸaÄŸÄ±ya iner, &quot;3. Exit&quot; aÅŸaÄŸÄ±ya iner, &quot;Choice&gt; &quot; yazar ve 0 ile bitirir.
// Her 0ah&#x27;den Ã¶nce 0dh geliyor. ÅÃ¶yle dÃ¼ÅŸÃ¼nÃ¼lebilir. 0ah yazÄ±lÄ±rken yani bir satÄ±r
// aÅŸaÄŸÄ±ya ineceÄŸimizi, ÅŸuanlÄ±k string&#x27;in bittiÄŸini string&#x27;in bilmesi gerekiyor.
// 0dh ise bunu bildiriyor.</code></pre><pre id="a768e848-547c-4a45-a2e3-df5b065c8d8e" class="code"><code>DUP Operator

// DUP; iÃ§eriÄŸi, parantez iÃ§erisinde belirtilen
// deÄŸer olacak ÅŸekilde bellekte yer ayÄ±rÄ±r.
// Belirtilen deÄŸer sabit bir deÄŸer olmalÄ±dÄ±r.

var1 BYTE 20 DUP(0) ; 20 bytes, all equal to zero
// Her bir byte&#x27;Ä±n deÄŸeri 0 olan, 20 byte&#x27;lÄ±k yer ayÄ±rÄ±r.

var2 BYTE 20 DUP(?) ; 20 bytes, uninitialized
// Her biri unitialized olan 20 byte&#x27;lÄ±k yer ayÄ±rÄ±r.

var3 BYTE 4 DUP(&quot;STACK&quot;) ; 20 bytes: &quot;STACKSTACKSTACKSTACK&quot;
// Her byte&#x27;Ä±nda iÃ§erik olarak STACK yazan 4 byte&#x27;lÄ±k yer ayÄ±rÄ±r.

var4 BYTE 10,3 DUP(0),20 ; 5 bytes
// birinci elemanÄ± 10, DUP ile her elemanÄ±n deÄŸerinin 0 olacaÄŸÄ±nÄ± belirttiÄŸive 3 byte
// ayÄ±racaÄŸÄ±nÄ± belirttiÄŸi iÃ§in
// 2., 3. ve 4. elemanlarÄ± 0 olan,
// 5. elamanÄ± ise 20 olan 5byte&#x27;lÄ±k bir dizi oluÅŸturur</code></pre><pre id="d414a6e0-6b31-4048-97e9-c058762f5527" class="code"><code>val1 WORD 65535 ; largest unsigned value

val2 SWORD â€“32768 ; smallest signed value

word3 WORD ? ; uninitialized, unsigned

word4 DWORD &quot;ABCD&quot; ; four characters

myList WORD 1,2,3,4,5 ; array of words

array WORD 5 DUP(?) ; uninitialized array
// DeÄŸeri unitialized olan 5 byte&#x27;lÄ±k dizi oluÅŸturur.

val5 DWORD 0FFFF0000h ; unsigned

val6 SDWORD â€“2147483648 ; signed

dwd7 SDWORD â€“2,â€“1,0,1,2 ; signed array

qwd8 QWORD 1234567812345678h

rVal1 REAL4 -2.1

rVal2 REAL8 3.2E-260

// Mor rengiyle gÃ¶sterilen Ã¼Ã§ tanesi kullanacaÄŸÄ±mÄ±z, Ã¶nemli tipler deÄŸiller.</code></pre><pre id="4cc73610-a649-4387-9417-74739356895c" class="code"><code>Little Endian Order: Bir byte&#x27;dan daha bÃ¼yÃ¼k bÃ¼tÃ¼n veri tipleri kendi verilerini
RAM&#x27;e sÄ±rayla(ters sÄ±rayla) yazar. Ã–rnek aÅŸaÄŸÄ±dadÄ±r:
Ancak bu, sadece sayÄ±larÄ± iÃ§in geÃ§erlidir.
Komtlar iÃ§in bu geÃ§erli deÄŸildir. 
Mesela 0AB2 komutu ters ÅŸekilde yazÄ±lmaz 2 byte olmasÄ±na raÄŸmen.</code></pre><figure id="a84ae741-bf13-4a4a-96e4-2bfa44738a9b" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/order.png"><img style="width:709px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/order.png"/></a></figure><hr id="74c5706e-7897-4b70-bb69-3759ca1ada4f"/><h3 id="967f47de-197f-4ec0-8750-d7bfacf674df" class="">PekiÅŸtirme Ã–nemli ğŸ˜‰</h3><figure id="c25a61d6-cff2-4f97-acb8-02c304a5edb8" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/pekitir.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/pekitir.png"/></a></figure><pre id="3de27b34-e329-46ab-8a49-cd14febb2a0c" class="code"><code>Declaring Uninitialized Data

.data?
array1 DWORD 5000 DUP (?)
// .data? segmentinde tanÄ±mlanan deÄŸiÅŸkenler iÃ§in uygulamanÄ±n(.exe) Ã§alÄ±ÅŸma zamanÄ±nda
// yer ayrÄ±lÄ±r. EXE(uygulamanÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±)&#x27;de bu deÄŸiÅŸken boyutu dahil deÄŸildir.

.data
array1 DWORD 5000 DUP (?)
// Bu deÄŸiÅŸkenin boyutu EXE&#x27;ye dahildir.</code></pre><pre id="685fe521-8410-4814-a0c9-c35e8bafd3e9" class="code"><code>Integer Symbolic Constant

name = expression
// name, bir sabittir. DeÄŸeri sonradan deÄŸiÅŸtirilebilir ama deÄŸiÅŸtirmek iyi bir
// seÃ§enek deÄŸil

sabit = 50
// sabit deÄŸiÅŸkenine 50 deÄŸerini atar.</code></pre><pre id="32b3e366-f899-4683-9a5c-16e4e2ad178b" class="code"><code>EQU Directive
// Constant (Dillerdeki const ile aynÄ± ÅŸey)

var EQU 80
// var isimli bir sabit oluÅŸturur ve 80 deÄŸerini atar. Bu sabit bir daha deÄŸiÅŸtirilemez.
// Ä°Ã§ine herhangi bir deÄŸer atanabilir.</code></pre><pre id="69f46d56-fba3-4c12-a80d-0ca3b406cfef" class="code"><code>TEXTEQU Directive

msg TEXTEQU 12
msq TEXTEQU %(msg)
// deÄŸeri 12 olan msg adÄ±nda bir sabit tanÄ±mlar.
// &#x27;%&#x27; ifadesi integer&#x27;i string&#x27;e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
// TEXTEQU  ile EQU&#x27;nun farkÄ±, TEXTEQU&#x27;nun sonradan deÄŸiÅŸtirilebilir olmasÄ±dÄ±r.</code></pre><pre id="303753ca-60fc-47b8-9580-c3013913d4fc" class="code"><code>Array Size(Dizi boyutu)

$ -&gt; ÅŸuanki satÄ±rÄ±n konumunu verir.

list BYTE 10,20,30,40
listSize = ($ - list)
// byte tipinde list adÄ±nda bir liste oluÅŸturur. SaÄŸdaki parametreleri eleman olarak alÄ±r
// symbolic constant olarak listSize sabitine, ÅŸimdiki satÄ±rÄ±n adresi - listenin baÅŸlangÄ±Ã§
// adresi arasÄ±ndaki farkÄ± atar. Bu fark da listenin eleman sayÄ±sÄ±*veri tipinin boyutunu verecektir.
Yani burada veri tipi 1 Byte ve 4 eleman olduÄŸu iÃ§in 1*4 = 4 olacaktÄ±r.

list2 DWORD 1,2,3,4
listSize2 = ($-list2)/4
// DWORD boyutu 4 byte olduÄŸu iÃ§in listSize2 direk olarak eleman sayÄ±sÄ±nÄ± verecektir.
// Ã‡Ã¼nkÃ¼ zaten veri tipi boyutuna bÃ¶ldÃ¼k.</code></pre><figure id="04f1c18a-e37b-489b-9a81-c672dc2c1f3f" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_003851.png"><img style="width:726px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_003851.png"/></a></figure><pre id="3a379968-ff3f-453b-b56f-38d65ecd0267" class="code"><code>Direct Memory Operands

Direct memory operands; Bellekte isimlendirilmiÅŸ bir referanstÄ±r.
Named reference(label/deÄŸiÅŸken isimleri de denebilir) de aslÄ±nda referansÄ± kÄ±rÄ±lmÄ±ÅŸ
bir direct memory&#x27;dir.
// C&#x27;deki pointer&#x27;lar gibi aslÄ±nda. Direct memeory denen ÅŸey
// bildiÄŸimiz pointer. DeÄŸiÅŸkenler de referansÄ± kÄ±rÄ±lmÄ±ÅŸ yani deÄŸerini gÃ¶steren
// pointer&#x27;lar gibi oluyor.

.data
var1 BYTE 10h

.code
mov al,var1 ; AL = 10h
mov al,[var1] ; AL = 10h
// &#x27;var1&#x27; in kÃ¶ÅŸeli parantez iÃ§ine alÄ±nmasÄ± bir ÅŸeyi deÄŸiÅŸtirmez.
// AslÄ±nda normal deÄŸiÅŸken ve dizi tanÄ±mlamalarÄ±nda, deÄŸiÅŸkeni ya da dizi elemanÄ±nÄ±
// kÃ¶ÅŸeli parantez iÃ§ine almak bir ÅŸeyi deÄŸiÅŸtirmez. Zaten direk deÄŸerini verecektir.
// KÃ¶ÅŸeli parantezin iÅŸe yaradÄ±ÄŸÄ± yerler, iÃ§inde bir adres tutulan memory/registerin
// iÃ§indeki adresin deÄŸerini almaktir ki bunu ileriki safhalarda gÃ¶receÄŸiz.</code></pre><h3 id="138fa14d-fed2-4b81-8fbb-9ed48fbb4032" class="">Mov Instruction Hata DurumlarÄ±</h3><pre id="f1893ebc-d703-416c-a160-3f6a94ecc65c" class="code"><code>.data
	bVal BYTE 100
	bVal2 BYTE ?
	wVal WORD 2
	dVal DWORD 5

.code
	mov al,wVal
	// vWal 2 byte, al(register tipi) ise 1 byte. BoyutlarÄ± farklÄ± olduÄŸu iÃ§in hata

	mov ax,bVal
	// bVal 1 byte, ax(register tipi) ise 2 byte. BoyutlarÄ± farklÄ± olduÄŸu iÃ§in hata

	mov eax,bVal
	// bVal 1 byte, eax(register tipi) ise 4 byte. BoyutlarÄ± farklÄ± olduÄŸu iÃ§in hata

	mov ds,45
	// ds, bir segment register&#x27;dir. Segment registere atama yapÄ±lamaz.	

	mov eip,dVal
	// sebebini ben de tam bilmiyorum. GeÃ§ersiz atama diyor. eip, bir pointer register.
	// Muhtemelen pointer register&#x27;lere atama yapÄ±lamÄ±yor(sallamasyon fikrim)

	mov 25,bVal
	// immediate ifadelere atama yapÄ±lamaz.

	mov bVal2,bVal
	// Memory&#x27;den memory&#x27;e direk atama yapÄ±lamaz.
</code></pre><pre id="40df5e6a-10bb-4363-a035-09ff6f2b915f" class="code"><code>Zero Extension (MOVZX instruction)

Daha bÃ¼yÃ¼k boyuta sahip bir registere&#x27;e, daha kÃ¼Ã§k boyuta sahip bir deÄŸer atandÄ±ÄŸÄ±nda
fazla kalan kÄ±sÄ±m 0&#x27;lar ile doldurulur

mov bl,10001111b
movzx ax,bl
// Boyutu 1 byte olan BL registerine, binary bir deÄŸer atanÄ±yor. Daha sonra bu register&#x27;i
// ax registerine atamaya Ã§alÄ±ÅŸÄ±rsak ax&#x27;in boyutu 2 byte olduÄŸundan
// kalan 1 byte 0&#x27;lar ile dolacaktÄ±r
// AX yani destination operand her zaman register olmalÄ±dÄ±r 0&#x27;lar ile dolmasÄ± iÃ§in</code></pre><pre id="59466dd7-677f-41ab-88b8-a32a96cbb62e" class="code"><code>Sign Extension (MOVSX Instruction)

Daha bÃ¼yÃ¼k boyuta sahip bir registere&#x27;e, daha kÃ¼Ã§Ã¼k boyuta sahip bir deÄŸer atandÄ±ÄŸÄ±nda
fazla kalan kÄ±sÄ±m, source&#x27;nin sign(iÅŸaret) biti ile doldurulur

mov bl,10001111b
movsx ax,bl

// AX yani destination operand her zaman register olmalÄ±dÄ±r.</code></pre><pre id="f29f9567-22c5-43bb-999d-44cf9b06a076" class="code"><code>XCHG Instruction (swap) (Excahnge&#x27;den geliyor)

Ä°ki operandÄ±n deÄŸerlerini deÄŸiÅŸtirir.
Ä°ki operanddan en az biri  register olmalÄ±dÄ±r.
Operandlardan herhangi biri immediate(sabit deÄŸer ya da constant) olamaz.
Ã‡Ã¼nkÃ¼ immediate deÄŸer depolanmaz ki deÄŸeri deÄŸiÅŸebilsin.


.data
var1 WORD 1000h
var2 WORD 2000h

.code
xchg ax,bx ; exchange 16-bit regs
xchg ah,al ; exchange 8-bit regs
xchg var1,bx ; exchange mem, reg
xchg eax,ebx ; exchange 32-bit regs

xchg var1,var2 // iki operand da memory olamaz. Burada hata verir.</code></pre><pre id="07ae31ba-aa08-4d2a-8c98-3ca0bf8dc2cf" class="code"><code>LAHF &amp; SAHF Instructions

LAHF: FLAG registerlerinin low byte&#x27;Ä±nÄ± ah registerine kopyalar. Bu registerler arasÄ±nda
Sign, Carry, Zero flag&#x27;larÄ± da vardÄ±r.
Flag&#x27;lar 16 bittir. Bunun low byte&#x27;Ä± ise ilk 8 flag tÃ¼rÃ¼ oluyor. BunlarÄ± kopyalar yani.
AmacÄ± ise flag&#x27;larÄ± bir deÄŸiÅŸkende gÃ¼vende tutmak iÃ§in saklamaktÄ±r.
LAHF, herhangi bir operand almaz. Direk flag&#x27;larÄ± ah&#x27;ye taÅŸÄ±r.

.data
	saveflag BYTE ?

.code
	lahf
	mov saveflag ah; lahf ile ah&#x27;ye kopyalanmÄ±ÅŸ olan flag deÄŸerlerini larÄ± saveflag deÄŸiÅŸkenine aktardÄ±k.

SAHF: AH registerindek flag deÄŸerlerini flag&#x27;lara geri kopyalar.

.code
	mov ah, saveflags; saveflags deÄŸiÅŸkenindeki flag&#x27;larÄ± ah ye geri atÄ±yoruz.
	sahf; ah&#x27;deki flag deÄŸerlerini flag&#x27;lere geri yerleÅŸtirir(kopyalar)
	</code></pre><figure id="25cedc9b-94eb-4db1-88be-dfd0c6858db3" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_131403.png"><img style="width:757px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_131403.png"/></a><figcaption>Ä°ÅŸaretli olanlar Ã¶nemliler</figcaption></figure><pre id="9e40e30a-e4ec-4fb4-bceb-128517dff694" class="code"><code>Direct Offset Operand

data label&#x27;ine(deÄŸiÅŸken ismi) ekleme yapÄ±larak baÅŸka adreslere gidilmesidir.
Bu iÅŸlem, memory&#x27;deki adresin deÄŸerini almak iÃ§in referansÄ± kÄ±rar. Adresi deÄŸil iÃ§indeki deÄŸeri alÄ±r.

.data

arrayB BYTE 10h,20h,30h,40h
// 4 elemanlÄ± bir Byte tipinde bir dizi oluÅŸturuldu

mov al, [dizi+ n.eleman*veri tipi boyutu] -&gt; dizinin kaÃ§Ä±ncÄ± elemanÄ±nÄ± istersek deÄŸerini bize verir.

.code
mov al,arrayB+1 ; AL = 20h
// ArrayB ile dizinin baÅŸlangÄ±Ã§ adresine gider.. Bu adrese +1 eklenmesi 1 Byte eklemek anlamÄ±na
// gelir. Diziler ardÄ±ÅŸÄ±k hafÄ±za alanlarÄ± olduÄŸu iÃ§in ve veri tipi de 1 Byte olduÄŸu iÃ§in
// +1 ekleyerek dizinin sonraki elemanÄ±na ulaÅŸabiliriz. 

mov al,[arrayB+1] ; alternatif gÃ¶sterim

Ã–rnek

.data
	arrayW WORD 1000h,2000h,3000h
	arrayD DWORD 1,2,3,4

.code
	mov ax,[arrayW+2]; 2000h
	// eklenen her sayÄ± 1 Byte olduÄŸu iÃ§in 2*1&#x27;den 2 Byte eder. arrayW&#x27;nin veri tipi WORD
	// yani 2 byte olduÄŸu iÃ§in hafÄ±zada 1.indexe yani 2. elamana gidecektir.

	mov ax,[arrayW+4]; 3000h
	// eklenen her sayÄ± 1 Byte olduÄŸu iÃ§in 4*1&#x27;den 4 Byte eder. arrayW&#x27;nin veri tipi WORD
	// yani 2 byte olduÄŸu iÃ§in hafÄ±zada 2.indexe yani 3. elamana gidecektir.

	mov ax, [arrayW+6]; 1
	// arrayW+6, arrayD&#x27;nin baÅŸlangÄ±Ã§ adresine gitmiÅŸ olur. arrayW+4 son elmanÄ±n baÅŸlangÄ±Ã§ adresine gidiyor
	// Ancak daha dizi sona ermedi. 2 Byte daha eklenirse dizi son bulacak. Dizinin son
	// bulma adresi ise arrayD&#x27;nin baÅŸlangÄ±Ã§ adresi yani arrayD&#x27;nin ilk elemanÄ±

	mov eax,[arrayD+4]; 2
	// arrayD&#x27;nin tipi DWORD yani 4 Byte olduÄŸu iÃ§in ArrayD&#x27;nin ikinci elemanÄ±nÄ± getirecek

	mov ax,[arrayD-2]; 3000h
	// ArrayD&#x27;nin baÅŸlangÄ±Ã§ adresinden 2 Byte geri gidersek arrayW&#x27;nin son elemanÄ±nÄ±n
	// baÅŸlangÄ±Ã§ adresine ulaÅŸmÄ±ÅŸ oluruz.

	mov eax,[arrayD+20]; Possible segmentation fault
	// arrayD&#x27;ye 20 eklersek 5. elemana gitmek istediÄŸimiz belirtmiÅŸ oluruz. Ancak bu dizinin 
	// 5. elamanÄ± yok. Dizinin bitiÅŸinden sonra adres olup olmadÄ±ÄŸÄ±nÄ± ya da adrese eriÅŸim
	// yetkimizin olup olmadÄ±ÄŸÄ±nÄ± bilemeyiz. Bu yÃ¼zden segmentation fault alma ihtimalimiz var
	// Kesin bir cevap veremeyiz. </code></pre><pre id="d608d46b-85b1-49aa-9975-7cbd29c0de0b" class="code"><code>Ã–rnek: AÅŸaÄŸÄ±daki dizindeki sayÄ±larÄ± toplayÄ±n.

.data
myBytes BYTE 80h, 66h, 0A5h

Ã‡Ã¶zÃ¼m:

mov al, myBytes
add al, [myBytes+1]
add al,[myBytes+2]</code></pre><pre id="380c0c98-198c-4529-a068-097d181791e5" class="code"><code>INC &amp; DEC Instructions (Bir artÄ±rma &amp; Eksiltme)

Bir tane operand alÄ±r ve aldÄ±ÄŸÄ± operandÄ±n deÄŸerini
INC bir artÄ±rÄ±r
DEC bir azaltÄ±r
Operand register da olabilir memeory de
Carry Flag&#x27;in durumunu etkilemezler.

.data

myWord WORD 1000h
myDword DWORD 10000000h

.code
inc myWord ; 1001h
dec myWord ; 1000h
inc myDword ; 10000001h
mov ax,00FFh
inc ax ; AX = 0100h
mov ax,00FFh
inc al</code></pre><pre id="2358f296-f4ed-4612-b88a-9df00dc739bf" class="code"><code>Add &amp; SUB Instructions (Toplama &amp; Ã‡Ä±karma Ä°ÅŸlemi)
SaÄŸdaki operand ile soldaki operand(a/dan) ekler/Ã§Ä±karÄ±r.

.data
	var1 DWORD 10000h
	var2 DWORD 20000h

.code
	mov eax,var1 ; 00010000h
	// eax registerine var1 deÄŸiÅŸkenini atar.

	add eax,var2 ; 00030000h
	// eax(32 bit acumulator register)&#x27;a va2&#x27;nin deÄŸerini ekler.

	add ax,0FFFFh ; 0003FFFFh
	// ax(16 bit acumulator register)&#x27;a  0FFFFh deÄŸerini ekler.
	add eax,1 ; 00040000h
	// eax registerine 1 deÄŸerini ekler
	sub ax,1 ; 0004FFFFh
	// ax registerinden 1 Ã§Ä±karÄ±r.

EAX 32 bit registerdir ve ALU(hesaplama) iÅŸlemleri iÃ§in kullanÄ±lÄ±r.
AX ise 16 bit registerdir ve aynÄ± iÅŸlemler iÃ§in kullanÄ±lÄ±r.
EAX&#x27;Ä±n 32 bitini dÃ¼ÅŸÃ¼nÃ¼rsek AX bu 32 bitin en saÄŸdaki(deÄŸeri az olan) 16 bitine denir.
Bu yÃ¼zden EAX&#x27;a bir deÄŸer eklemek ile AX&#x27;a bi deÄŸer eklemek arasÄ±nda fark yoktur.
Bu nedenle EAX ve AX Ã¼zerinde toplama iÅŸlemi yapabildik sanki aynÄ± registermiÅŸ gibi.
Ancak bu Ã§ok fazla kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na neden olur. Bir iÅŸlemde mÃ¼mkÃ¼n oldukÃ§a sadece
bir tanesi kullanÄ±lmalÄ±</code></pre><pre id="1d3ab4c4-0211-4b3a-83be-6f1d33f3a200" class="code"><code>NEG Instruction (iÅŸaretinin tersini alma)

Tek bir operand alÄ±r ve operandÄ±n iÅŸaretinin tersini alÄ±r. (2&#x27;li tÃ¼mleyene gÃ¶re)
DeÄŸeri &#x27;0&#x27; olmayan bir operandÄ±n carry flag&#x27;Ä±nÄ± her zaman 1 yapar.


.data
valB BYTE -1
valW WORD +32767

.code
mov al,valB ; AL = -1
neg al ; AL = +1
neg valW ; valW = -32767

EÄŸer WORDÃœn alabileceÄŸi boyuttan daha fazla bir atama yaparsak ve bunun negatifini
almaya Ã§alÄ±ÅŸÄ±rsak bize yanlÄ±ÅŸ sonuÃ§ dÃ¶ndÃ¼recektir.
TaÅŸma olacaÄŸÄ±ndan dolayÄ± overflow biti 1 olacaktÄ±r.</code></pre><pre id="a4f0e670-7dfd-41a6-9bbc-7ac708186044" class="code"><code>FLAGS

ALU, aritmetik iÅŸlemlerin sonucunu dÃ¶ndÃ¼ren bir dizi durum flag&#x27;ine sahiptir.

DeÄŸer alarak 1 ya da 0 alÄ±r. Genelde durum beklendiÄŸi gibiyse 1 deÄŸilse 0 alÄ±r

MOV komutu flag&#x27;leri etkilemez.

Flag&#x27;lar operandlar&#x27;dan destination operandÄ± ile ilgilidir.

add myVar, AX
// myVar destination, AX ise source&#x27;dir.

Temel flag&#x27;lar:

- Zero flag : destination 0&#x27;a eÅŸit ise 1
- Sign flag : destination negatif ise 1
- Carry flag : iÅŸaretsiz deÄŸer out of range(olmasÄ± gereken sÄ±nÄ±rÄ±n dÄ±ÅŸÄ±da) ise 1
- Overflow flag : iÅŸaretli deÄŸer out of range ise 1</code></pre><figure id="422a5db8-b654-49f1-b51a-4138b377202d" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_205121.png"><img style="width:746px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-14_205121.png"/></a></figure><pre id="d32448d7-c206-4546-b98b-1563d409b101" class="code"><code>Zero Flag

EÄŸer destination operandÄ±n sonucu 0 ise flag 1 olur
ZF = Zero Flag

mov cx,1
sub cx,1 ; CX = 0, ZF = 1
mov ax, 0FFFFh
add ax,1 ; AX = 0, ZF = 1
add ax,1 ; AX = 1, ZF = 0</code></pre><pre id="bd04ab13-1a13-4af2-9d01-d8234d54fd4c" class="code"><code>Sign Flag

EÄŸer destination operandÄ±n sonucu negatif ise flag 1 olur. Pozitife dÃ¶nerse 0 olur
SF = Sign Flag

mov cx,0
sub cx,1 ; CX = -1, SF = 1
add cx,2 ; CX = 1, SF = 0

Sign flag; en bÃ¼yÃ¼k bitin aynÄ±sÄ±dÄ±r. Yani MSB biti 1 ise 1, 0 ise sign flag da 0&#x27;dÄ±r

mov al,0
sub al,1 ; AL = 11111111b, SF = 1
add al,2 ; AL = 00000001b, SF = 0</code></pre><pre id="b30ede8e-8097-47a1-a680-9144f667832f" class="code"><code>Tam SayÄ±larÄ±n Ä°ÅŸareti

Ä°ÅŸlemci, iÅŸaretli(signed) ve iÅŸaretsiz(unsigned) tamsayÄ±lara aynÄ± ÅŸekilde davranÄ±r.

Ä°ÅŸaretli ve iÅŸaretsiz tamsayÄ±larÄ± ayÄ±rt etmez.

Her instruction iÃ§in doÄŸru veri tipini uygulamak programcÄ±nÄ±n gÃ¶revidir.</code></pre><pre id="a263b4fe-c21b-41ed-a0f2-9246fe30b2d4" class="code"><code>Carry Flag

Size hatasÄ± Ã§Ä±karsa flag 1 olur (unsigned olarak deÄŸerlendirilir)

mov al,0FFh
add al,1 ; CF = 1, AL = 00
// al register&#x27;inin boyutu 1 byte&#x27;dÄ±r. 0FF de 1 byte yer kaplar. Ancak buna 1
// eklendiÄŸi zaman al registerinin boyutu aÅŸÄ±lacak ve carry flag 1 olacak.

mov ax,0FFh
add ax,1
// ax registerinin boyutu 2 byte&#x27;tÄ±r. 0FF de 1 byte yer kaplar. Buna 1
// eklendiÄŸi zaman al registerinin boyutu aÅŸÄ±lmayacak ve carry flag 0 olacak.</code></pre><pre id="9f095530-0a75-424d-b8a2-24fdcbba5107" class="code"><code>Ã–rnekler

mov ax,00FFh

add ax,1 ; AX=0100h, SF=0 ZF=0 CF=0
// boyutu 2 byte, deÄŸeri 00FFh olan ax registerine 1 eklemek boyut sorununa neden olmaz
// Bu yÃ¼zden CF=0; SayÄ±mÄ±z pozitif olduÄŸu iÃ§in SF=0; ax&#x27;Ä±n deÄŸeri 0 olmadÄ±ÄŸÄ± iÃ§in
// ZF=0

sub ax,1 ; AX=00FFh, SF=0 ZF=0 CF=0
// boyutu 2 byte, deÄŸeri 0100h olan ax registerinden 1 Ã§Ä±karmak boyut sorununa neden olmaz
// Yani CF=0; SayÄ±mÄ±z pozitif olduÄŸu iÃ§in SF=0; ax&#x27;Ä±n deÄŸeri 0 olmadÄ±ÄŸÄ± iÃ§in

add al,1 ; AL=00h, SF=0 ZF=1 CF=1
// boyutu 1 byte, deÄŸeri 00FFh olan al registerine 1 eklemek boyut sorununa neden olur.
// Ã‡Ã¼nkÃ¼ 1byte&#x27;lÄ±k registerin Ã¼stÃ¼ne Ã§Ä±kmÄ±ÅŸ oluyoruz. Yani CF=1; 1 ile toplayÄ±nca
// boyut sorunlarÄ± ortaya Ã§Ä±ksa da al&#x27;nin 8 biti 0 olmaktadÄ±r. Bu yÃ¼zden ZF=0;
// MSB biti 0 olduÄŸu iÃ§in SF=0

mov bh,6Ch
add bh,95h ; BH=01h, SF=0 ZF=0 CF=1
// boyutu 1 byte, deÄŸeri 00FFh olan bh registerine 1 eklemek boyut sorununa neden olur. 
// Ã‡Ã¼nkÃ¼ 1byte&#x27;lÄ±k registerin Ã¼stÃ¼ne Ã§Ä±kmÄ±ÅŸ oluyoruz. Yani CF=1; 95h ile toplayÄ±nca 
// boyut sorunlarÄ± ortaya Ã§Ä±ksa da al&#x27;nin 7 biti 0 ve LSB(en saÄŸdaki bit) 1 olmaktadÄ±r.
// Hepsi 0 olmadÄ±ÄŸÄ± iÃ§in ZF=0; MSB biti 0 olduÄŸu iÃ§in SF=0

mov al,2
sub al,3 ; AL=FFh, SF=1 ZF=0 CF=1
// 2 -3 = -1; -1&#x27;in karÅŸÄ±lÄ±ÄŸÄ±: 1111 1111&#x27;dir. MSB biti 1 olduÄŸundan SF=1, sonuÃ§ 0 olmadÄ±ÄŸÄ±
// iÃ§in ZF=0, CF=1</code></pre><pre id="6d13f369-e09d-4415-ad19-fcd9b54bbd5e" class="code"><code>Overflow Flag

Aritmetik iÅŸlemlerde iÅŸaret hatasÄ± Ã§Ä±karsa flag 1 olur.

mov al,+127
add al,1 ; OF = 1, AL = -128
// 127 ile 1&#x27;i toplayÄ±nca cevap -128 Ã§Ä±kÄ±yor. Bu yÃ¼zden iÅŸaret hatasÄ± olur yani OF=1

mov al,7Fh ; OF = 1, AL = 80h
add al,1
// 7F = 127. 127 ile 1&#x27;i toplayÄ±nca cevap -128 Ã§Ä±kÄ±yor.
// Bu yÃ¼zden iÅŸaret hatasÄ± olur yani OF=1

Destination operandÄ±nÄ±n deÄŸerini hesaplamak hexadecimal&#x27;de genelde daha kolaydÄ±r.
Yani Ã¶nce artitmetik iÅŸlemleri hex&#x27;te yapÄ±p binary&#x27;de flag&#x27;larÄ± bulmak daha kolaydÄ±r

Toplanan iki deÄŸer pozitif ise ya da Ã§Ä±karÄ±lan deÄŸerlerin iÅŸareti farklÄ± olduÄŸunda
overflow bit 1 olur. Aksi duruda overflow durumu oluÅŸamayacaktÄ±r. Kontrol etmeye gerek
olmayacaktÄ±r</code></pre><pre id="7fd7ddb8-3716-44a1-b237-ac3f94561f71" class="code"><code>Bilgisayar bir aritmetik iÅŸlemin signed ya da unsigned olduÄŸunu anlayamaz.
Sadece verilen iÅŸlemleri yapar.
Burada programcÄ±nÄ±n iÅŸi, signed ya da unsigned olduÄŸunu iÅŸlemciye bildirmektir.</code></pre><pre id="de40f0bc-9200-4ca9-8205-c17edee98e9e" class="code"><code>ALIGN Directive

Bellekte, adresi boÅŸ bÄ±rakÄ±r. ÅÃ¶yle ki;
ALIGN, kendisine operand olarak verilen byte deÄŸerinden kendisinden Ã¶nce gelen komutun
boyutunu Ã§Ä±karÄ±r. Ve bellekte o kadar boÅŸ yer ekler. Bunun nedenlerinden birisi
(hafta 7&#x27;de gÃ¶receÄŸimiz) RISC mimarisinin tek adreslerde iÅŸlem yapamamasÄ±. 

bVal BYTE ? ; 00404000
ALIGN 2 ; EÄŸer biz burada ALIGN yapmasak bir sonraki komutun adresi 00404001 olacaktÄ±.
	        Ancak RISC bu adrese gidip iÅŸ yapamayacaÄŸÄ± iÃ§in adresine 1 byte daha ekliyor.  
wVal WORD ? ; 00404002
bVal2 BYTE ? ; 00404004
ALIGN 4  ; Burada ALIGN yapmasak bir sonraki komutun adresi 00404005 olacaktÄ±. Yine tek
				 ; adrese denk gelecekti. Ama biz dedik ki; &#x27;ben 4 byte&#x27;lÄ±k yer ayÄ±rÄ±cam.
				 ; Ama Ã¼stteki komut zaten bunun 1 byte&#x27;Ä±nÄ± almÄ±ÅŸ. Ben 3 byte ekleyeyim de
				 ; sonraki adrese tam 4 eklenmiÅŸ olsun.&#x27;
dVal DWORD ? ; 00404008
dVal2 DWORD ? ; 0040400C</code></pre><pre id="2531485f-bc27-4638-832e-96ffff0d615b" class="code"><code>PTR Operator

- Bir label&#x27;in(variable/deÄŸiÅŸken) varsayÄ±lan tipinin Ã¼zerine yazar.
	Ã–rneÄŸin sayi diye bir deÄŸiÅŸkenimiz olsun. Tipi de WORD olsun.
	Bu deÄŸiÅŸkene ileride DWORD tipinde bir deÄŸer atmak istersek sayinin tipini PTR
	ile varsayÄ±lan tipini DWORD yapabiliriz.
- DeÄŸiÅŸkenin bir bÃ¶lgesine eriÅŸmede esneklik saÄŸlar.
- Bir tane tip belirteci alÄ±r.

.data
myDouble DWORD 12345678h

.code
mov ax,myDouble
// AX&#x27;Ä±n boyutu 2 byte&#x27;dÄ±r. Ancak AX&#x27;a, 4 byte olan deÄŸiÅŸkenimizi atmaya Ã§alÄ±ÅŸÄ±yoruz
// Peki bu 2 byte iÃ§inde hangi deÄŸerler olacak? SonuÃ§ta deÄŸiÅŸken 4 byte. Ve kalan
// 2 byte&#x27;a ne olacak? Birazdan cevabÄ±nÄ± bulacaÄŸÄ±z.

mov ax,WORD PTR myDouble
// Burada, yukarÄ±daki iÅŸlemin aynÄ±sÄ±nÄ± yapÄ±yoruz ancak bir farkla. PTR kullanÄ±yoruz.
// Diyoruz ki: &#x27;ax registerine myDouble deÄŸiÅŸkenimi at. Ama atarken tipini WORD
// tipine(2 byte) Ã§evir de at. BÃ¶ylece tipleri aynÄ± olur ve atama iÅŸlemi baÅŸarÄ±lÄ± olur&#x27;
// Peki soru ÅŸu: &#x27;4 byte olan deÄŸiÅŸkenimizi 2 byte&#x27;a indirdik. Geriye kalan 2 byte&#x27;a
ne oldu?&#x27;</code></pre><div id="0d24a697-5fad-45c0-a995-d97592a56f20" class="column-list"><div id="0c916aef-ebdd-434c-a16d-b2e43e88f509" style="width:25%" class="column"><figure id="851bc986-fdd5-4a70-ba8c-6405647b617e" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_111330.png"><img style="width:134px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_111330.png"/></a></figure></div><div id="e2cd2b48-cbc7-4650-a964-7705fe1c4a3a" style="width:75%" class="column"><pre id="3ab7f8e2-d6c4-424c-a512-0a51bac90932" class="code"><code>Little Endian Order&#x27;i hatÄ±rlayalÄ±m:
Bir byte&#x27;dan fazla olan veriler belleÄŸe ters olarak
yazÄ±lÄ±rdÄ±.
LSB yani en saÄŸdaki(en kÃ¼Ã§Ã¼k basamak) en Ã¼stte olur.

Yandaki ÅŸekil; 12345678h adresinin bellekte yerleÅŸimidir.
Ancak gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere ters olarak yerleÅŸmiÅŸ.

</code></pre></div></div><figure id="b010faea-d8f4-42a6-93ea-577bc93614ea" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_111842.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_111842.png"/></a></figure><pre id="7d69324c-7e1f-40bf-bbff-8879fdc6a766" class="code"><code>YukarÄ±da ise PTR operatÃ¶rÃ¼ kullanÄ±lmÄ±ÅŸ bir deÄŸiÅŸkenin adres yerleÅŸimini gÃ¶rÃ¼yoruz.

mov al,BYTE PTR myDouble ; AL = 78h
// myDouble deÄŸiÅŸkeninin boyutu 4 byte.
// Bunu, 1 byte olan &#x27;al&#x27; registerine atÄ±yoruz. Peki ne olacak?
// Malum Ã§oklu byte&#x27;lar Little Endian ile dizilirdi yani en saÄŸdaki basamak en Ã¼st
// bellek hÃ¼cresinde olurdu. Yani deÄŸerin baÅŸlangÄ±Ã§ noktasÄ± aslÄ±nda sayÄ±nÄ±n
// en saÄŸÄ±ndaki 2 bit. 4 byte&#x27;lÄ±k deÄŸiÅŸkeninin baÅŸlangÄ±Ã§ adresinin deÄŸerini alacak(78) ve 
// &#x27;al&#x27; registerine kopyalayacak. Bizim deÄŸiÅŸkenimizde bir bozulma olmayacak.
// Yine ulaÅŸabileceÄŸiz

mov al,BYTE PTR [myDouble+1] ; AL = 56h
// BaÅŸlangÄ±Ã§ adresimizin deÄŸeri 78 idi. Bu adrese 1 byte eklersek bir sonraki hafÄ±za
// bÃ¶lgesine gitmiÅŸ oluruz. &#x27;78&#x27;den sonra &#x27;56&#x27; geliyor. Bu durumda bizim &#x27;al&#x27;
// registerimiz 56 olacak.

mov al,BYTE PTR [myDouble+2] ; AL = 34h
// BaÅŸlangÄ±Ã§ adresimizin deÄŸeri 78 idi. Bu adrese 2 byte eklersek iki sonraki hafÄ±za
// bÃ¶lgesine gitmiÅŸ oluruz. &#x27;78&#x27;den iki sonra &#x27;56&#x27; geliyor. Bu durumda bizim &#x27;al&#x27;
// registerimiz 34 olacak.

mov ax,WORD PTR myDouble ; AX = 5678h
// BaÅŸlangÄ±Ã§ adresimizin deÄŸeri 78 idi. Ancak bizim tipimiz WORD yani 2 byte olduÄŸu
// iÃ§in 78&#x27;den sonra 1 byte daha yani 56 deÄŸerini de alacaÄŸÄ±z. Bu deÄŸerleri bellekten
// alÄ±p birleÅŸtirince bellekteki sÄ±rasÄ± ile gelemeyecek. BelleÄŸe yerleÅŸirken ters
// yerleÅŸtiÄŸi iÃ§in bize gelirken bir daha ters Ã§evriliyor. Bu yÃ¼zden iki bellek hÃ¼cresi
// birleÅŸtirip karÅŸÄ±mÄ±za 5678 olarak geliyor ve boyutu 2 byte olan ax registerine
// atanÄ±yor.

mov ax,WORD PTR [myDouble+2] ; AX = 1234h

PTR, sadece boyutu bÃ¼yÃ¼k deÄŸiÅŸkenlerin boyutunu daraltmaz.
Boyutu daha kÃ¼Ã§Ã¼k olan bir deÄŸiÅŸkeni boyutu bÃ¼yÃ¼k olan bir deÄŸiÅŸkene atabilir.</code></pre><figure id="eedf8827-29d3-40cc-8c1e-6bce4f153be9" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_113754.png"><img style="width:845px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_113754.png"/></a></figure><pre id="82a7a98f-adfc-4fed-82fd-9a489acce44d" class="code"><code>YukarÄ±daki Ã¶rnekte myBytes&#x27;a bir dizi atanmÄ±ÅŸ. Dizinin elemanlarÄ± belleÄŸe sÄ±ralÄ±
olarak yerleÅŸir. PTR ile bu deÄŸerler bir registere atanmak istenirse PTR yÃ¼zÃ¼nden
CPU bu deÄŸerleri ters Ã§evirecektir.
EÄŸer ters Ã§evirmese .code&#x27;un ilk komutunda ax&#x27;in 1234 olmasÄ± gerekirdi. Ä°ki bellek
hÃ¼cresini birleÅŸtirdi ve ters Ã§evirdi.</code></pre><pre id="a9d960c1-9cf4-46d8-a163-1fe65d75d329" class="code"><code>Type Operator

Kendisinden sonra gelen deÄŸiÅŸkenin tipinin boyutunu verir.
EÄŸer gelen deÄŸiÅŸken bir dizi ise her bir elemanÄ±n tipinin boyutunu verir.
Dizinin tipi ne ise onu verir yani.

.data
var1 BYTE ?
var2 WORD ?
var3 DWORD ?
var4 QWORD ?

.code
mov eax,TYPE var1 ; 1
// var1&#x27;in tipini dÃ¶ndÃ¼rÃ¼r. var1&#x27;in tipi ise 1 byte&#x27;dÄ±r.
// EÄŸer orada &#x27;type&#x27; operatoru olmasayaydÄ± eax registerine var1&#x27;in deÄŸeri atanacaktÄ±.
// Ancak artÄ±k orada var1 deÄŸil de var1&#x27;in tipinin boyutu olduÄŸu
// iÃ§in(type operatÃ¶rÃ¼, yazÄ±ldÄ±ÄŸÄ± yere boyutu return eder.) eax&#x27;a o atanacak
// var1&#x27;in tipi byte yan, 1 byte&#x27;dÄ±r.

mov eax,TYPE var2 ; 2

mov eax,TYPE var3 ; 4

mov eax,TYPE var4 ; 8</code></pre><pre id="9c0642c1-ecb4-49dd-b507-6776879bac6d" class="code"><code>Lengthof Operator

Bir deÄŸikenin eleman sayÄ±sÄ±nÄ± sayar ve geriye dÃ¶ndÃ¼rÃ¼r.

.data
byte1 BYTE 10,20,30

array1 WORD 30 DUP(?),0,0

array2 WORD 5 DUP(3 DUP(?))

array3 DWORD 1,2,3,4

digitStr BYTE &quot;12345678&quot;,0

.code
.mov ax, LENGTHOF byte1; 3
// yukarÄ±da byte1 deÄŸiÅŸkenine tipi byte olan 3 eleman ataanmÄ±ÅŸtÄ±r. Yani bir dizi
// oluÅŸturulmuÅŸ. Lengthof, burada 3 deÄŸerini geri dÃ¶ndÃ¼rÃ¼r.

mov ecx,LENGTHOF array1 ; 32
// yukarÄ±da ilk 30 deÄŸeri null olan, son iki deÄŸeri ise &#x27;0&#x27; olan bir dizi tanÄ±mlar ve
// array1 deÄŸiÅŸkenine atar. Length of bu yÃ¼zden 32 dÃ¶ndÃ¼recektir.</code></pre><pre id="194d69f1-372b-481d-b25d-6bbad437f266" class="code"><code>SIZEOF Operator

Sizeof = Lengthof * type

Bir deÄŸiÅŸkenin eleman sayÄ±sÄ±(lengthof) * elemanlarÄ±n veri tipini boyutunun Ã§arpÄ±mÄ±na 
eÅŸittir

.data
array1 WORD 30 DUP(?),0,0
// Lengthof&#x27;ta gÃ¶sterildiÄŸi gibi, tipi WORD(yani boyutu 2byte) 32 elemanlÄ± bir dizi
tanÄ±mladÄ±k.

.code
mov ecx, SIZEOF array1; ECX=64
// Array1&#x27;in boyutunu alÄ±p ecx registerine atar.
// !! sizeof, sadece integer bir sayÄ± dÃ¶ndÃ¼rÃ¼r,dizinin herhangi bir elemanÄ±nÄ± deÄŸil</code></pre><pre id="a1fa92df-80c6-4f30-8115-de224b3110d8" class="code"><code>Komutlar, birden Ã§ok satÄ±rda yazÄ±labilir. DiÄŸer komut girilene kadar
operandlarÄ±n/elemanlarÄ±n farklÄ± satÄ±rlarda girilmesinde sakÄ±nca yoktur

Ã–r: 

.data

array WORD 10,20,
30,40,
50,60

.code

mov eax,LENGTHOF array; 6
// FarklÄ± satÄ±rlarda olsa da toplam 6 elamanÄ± var.</code></pre><pre id="c80be76f-d0de-4a47-8bc8-5fb4c002e054" class="code"><code>Anonymous Data

BurayÄ± atlayÄ±n geÃ§in. Kafa karÄ±ÅŸtÄ±rÄ±cÄ±. Sorulmayacak

Bir komutun birden Ã§ok satÄ±rda yazÄ±labileceÄŸini ifade etmiÅŸtik.
Ancak bir array tanÄ±mlanÄ±rken ilk satÄ±r hariÃ§ diÄŸer satÄ±rdaki elemanlarÄ±n, yazÄ±lÄ±rken
tipi de belirtilirse o elemanlar dizinin elemanÄ± olmaz. Bilinmeyen bir veri olur.
Evet, aritmetiksel memory iÅŸlemleriyle byte artÄ±rarark onlara da ulaÅŸÄ±labilir ancak
diziye ait deÄŸillerdir hatta hiÃ§bir yere ait deÄŸildirler (evsiz barksÄ±zlar :D)
// Benim anladÄ±ÄŸÄ±m bu. Ama doÄŸrusu, benim anladÄ±ÄŸÄ±m gibi mi bilmiyorum.
// Ama muhtemelen sizeof ve lengthof&#x27;a Ã¶zel bir durum bu. Ã‡Ã¼nkÃ¼ internette
// bÃ¶yle bir ÅŸey bulamadÄ±m. Yani diziler yine Ã§oklu satÄ±rda tanÄ±mlanabilir.
// GÃ¶rdÃ¼ÄŸÃ¼m kadarÄ±yla bir sÄ±kÄ±ntÄ± yok. Dizinin elemanlarÄ±na ulaÅŸabiliyoruz.
// Ama Ã§ok takÄ±lmaya gerek olduÄŸunu dÃ¼ÅŸÃ¼nmÃ¼yorum.
// Ama bu aÃ§Ä±klamadan emin deÄŸilim.

.data
array WORD 10,20; array aslÄ±nda burada biter.
			WORD 30,40 ; anonymous data, array+4
			WORD 50,60 ; array+8

.code

mov eax,LENGTHOF array ; 2
// 30,40,50,60 elemanlarÄ± array&#x27;in bir elemanÄ± deÄŸildir. Bu yÃ¼zden array&#x27;Ä±n eleman
// 2 olmaktadÄ±r

mov ebx,SIZEOF array ; 4

!!! Sizeof ve lengthof operatÃ¶rleri runtime&#x27;da deÄŸil compile time&#x27;da Ã§alÄ±ÅŸÄ±r</code></pre><pre id="0ac4c9b1-7f4e-4a42-b271-5748df477508" class="code"><code>Label operatoru

	Tam anlayabilmiÅŸ deÄŸilim. Sadece gÃ¶z aÅŸinalÄ±ÄŸÄ± olsun

- Var olan bir hafÄ±za alanÄ±na bir isim takar.
- Memory&#x27;de label yazan komut iÃ§in de herhangi bir yer ayrÄ±lmaz.
- Pointer operatÃ¶rÃ¼nden kaÃ§Ä±nmak iÃ§in ihtiyaÃ§ duyulur(neden olduÄŸunu bilmiyorum)

.data

dwList LABEL DWORD
wordList LABEL WORD
byteList BYTE 00h,10h,00h,20h

.code

mov eax,dwList ; 20001000h
mov cx,wordList ; 1000h
mov dl,intList ; 00h
// Burada akÄ±lda kalmasÄ± gereken ÅŸey, eax ve cx registerlerinin ikisinin de deÄŸerinin
// aynÄ± olmasÄ±. Ã‡Ã¼nkÃ¼ dwList ve wordList, ikisi de aynÄ± bellek gÃ¶lgesine takÄ±lmÄ±ÅŸ isimler</code></pre><pre id="73fd8a5c-7a8c-4e20-9fe7-cbd67f3c2614" class="code"><code>OFFSET Operator

Bir memory alanÄ±nÄ±n, data segmentinin baÅŸlangÄ±cÄ±ndan ne kadar uzak olduÄŸunu gÃ¶sterir.

Ã–rnek iÃ§in varsayalÄ±m ki; bVal, &quot;00404000h&quot; adresinde oturuyor.


.data
bVal BYTE ?
wVal WORD ?
dVal DWORD ?
dVal2 DWORD ?

.code

mov esi,OFFSET bVal ; ESI = 00404000
// bval, 00404000 adresinde oturmaktadÄ±r. DoÄŸal olarak data segmentinin
// baÅŸlangÄ±cÄ±na(yani 0. adrese) uzaklÄ±ÄŸÄ± kendi adresi olacak.

mov esi,OFFSET wVal ; ESI = 00404001
// bVal 1 byte idi. bVal+1 byte, Wval&#x27;Ä±n adresini verir. Ã‡Ã¼nkÃ¼ komutlar sÄ±ralÄ±
// adreslemeye(bu yÃ¼zden deÄŸiÅŸkenler de sÄ±ralÄ± olur) sahiptir.
// wVal&#x27;Ä±n, data segmente uzaklÄ±ÄŸÄ± kendi adresidir. 

mov esi,OFFSET dVal ; ESI = 00404003
// vWal, WORD yani 2 byte. vWal+2, dVal&#x27;Ä±n adresini verir. dVal&#x27;Ä±n, data segmentine
// uzaklÄ±ÄŸÄ± kendi adresidir.

mov esi,OFFSET dVal2 ; ESI = 00404007

Offset&#x27;in en Ã¶nemli kullanÄ±mlarÄ±ndan birisi, deÄŸiÅŸkenin adresini tespit etmektir.
Ä°leride zaten bunu Ã§okÃ§a kullancaÄŸÄ±z.</code></pre><pre id="120ee189-0262-4213-87aa-dace52310b8a" class="code"><code>INDIRECT OPERANDS

DeÄŸiÅŸkenlerin adreslerini tutar. BildiÄŸimiz pointer yani

[degisken] ifadesi ile referans kÄ±rÄ±lÄ±r yani adresin iÃ§indeki deÄŸer alÄ±nabilir.
AÅŸaÄŸÄ±daki Ã¶rneÄŸe bakÄ±nÄ±z:</code></pre><pre id="a773942c-c4f2-4893-8c1c-fc1062b0e0f1" class="code"><code>int a = 5;
int *p = &amp;a;
printf(&quot;A&#x27;nÄ±n deÄŸeri = %d&quot;, *p)

//p, a&#x27;nÄ±n adresini tutarken printf iÃ§inde ise *p yaparak p pointerinin iÅŸaret ettiÄŸi
// dedÄŸiÅŸkenin deÄŸerini alabildik. Yani a&#x27;nÄ±n deÄŸeri. Bu da C&#x27;deki referans kÄ±rma olayÄ±
//Assembly&#x27;deki karÅŸÄ±lÄ±ÅŸÄ± = [p]</code></pre><pre id="c08c2346-44a4-4e7b-a202-bca661f925b1" class="code"><code>Offset operator&#x27;de; Offset&#x27;i birazdan kullanacaÄŸÄ±z, demiÅŸtim. Hah iÅŸte oraya geldik :)

.data
val1 BYTE 10h,20h,30h
// Bir deÄŸiÅŸken oluÅŸturup iÃ§ine 10,20,30 deÄŸerini atÄ±yoruz. Yani dizi yaptÄ±k.

.code
mov esi,OFFSET val1 ; esi, val1&#x27;in adresini depolar

mov al,[esi]
// [esi] ifadesi ile esi&#x27;nin depoladÄ±ÄŸÄ± adresi kÄ±rÄ±p iÃ§indeki deÄŸeri alÄ±r.
// Esi&#x27;nin depoladÄ±ÄŸÄ± adresin deÄŸerini alÄ±p &#x27;al&#x27; registerine atar.

inc esi
// esi registerini bir artÄ±rdÄ±k. ESI registeri ÅŸuanda val1 dizisinin baÅŸlangÄ±Ã§ adresini
// tutuyor. Yani biz ESI&#x27;yi bir artÄ±rÄ±rsak bir sonraki bir byte artacak. O da val1
// deÄŸiÅŸkeninin ikinci elamanÄ±na yani 20h&#x27;nin adresine denk geliyor. Ama dikkat ÅŸuan
// 20h&#x27;ye deÄŸil 20h&#x27;nin adresine geldik.

mov al,[esi] ; AL = 20h
// ESI, ÅŸuanda 20h elemanÄ±nÄ±n adresinde. EÄŸer o adresi dereferans yaparsak adresin
// iÃ§indeki elemanÄ± yani 20h&#x27;yi alabiliriz ki aldÄ±k da zaten :)
// AL registerinde ÅŸuanda 20h deÄŸeri var.

inc esi
// ESI, en son 20h&#x27;nin adresini tutuyordu. EÄŸer bir daha artÄ±rÄ±sak bu sefer 30h&#x27;nin
// adresini tutacak.

mov al,[esi] ; AL = 30h
// ESI, ÅŸuanda 30h elemanÄ±nÄ±n adresinde. EÄŸer o adresi dereferans yaparsak adresin
// iÃ§indeki elemanÄ± yani 30h&#x27;yi alÄ±yoruz.

Adresler genelde ESI VE EDI register&#x27;larÄ±nda tutulur. SI, source index anlamÄ±na
gelir ki hiÃ§ Ã¶nemli deÄŸil anlamÄ±
EDI de, Destination index anlamÄ±na gelir ki hakeza bunun da ismi hiÃ§ Ã¶nemli deÄŸil.
BaÅŸlarÄ±ndaki E de, 4 byte olduklarÄ±nÄ± gÃ¶sterir.
EAX, EBX vs AX, BX gibi</code></pre><pre id="d059d9c6-d0ba-4b8e-95da-3764735a8aee" class="code"><code>char array[1000];
char *p = array;

// C++ ve C&#x27;de bir dizi oluÅŸturup dizinin baÅŸlangÄ±Ã§ adresini p adÄ±nda bir pointer&#x27;e
// atadÄ±k. AÅŸaÄŸÄ±da ise bunu Assembly karÅŸÄ±lÄ±ÄŸÄ± var.</code></pre><pre id="1ad59b48-3b61-4169-97ab-60d98ba74487" class="code"><code>.data
	array byte 1000 DUP(?)
// Ä°Ã§leri boÅŸ olan 1000 elemanlÄ±k bir dizi oluÅŸturduk
// DUP opcode&#x27;unun ne iÅŸe yaradÄ±ÄŸÄ± dÃ¶kÃ¼manÄ±n baÅŸlarÄ±nda anlatÄ±ldÄ±.

.code
mov esi, OFFSET array
// Dizinin baÅŸlangÄ±Ã§ adresini ESI registerine atadÄ±k.</code></pre><pre id="1b25adcb-3aa8-4ae7-ab00-abd0f2204208" class="code"><code>INDIRECT OPERANDS &amp; PTR

PTR, operandÄ±n tipini aÃ§Ä±kÃ§a belirtmek iÃ§in kullanÄ±lÄ±r
OFFSET operatÃ¶rÃ¼ adresi bize verdiÄŸinde adresteki deÄŸerlerin boyutunu vermez.

.data
myCount WORD 0
// WORD tipinde bir deÄŸiÅŸken oluÅŸturup iÃ§ine 0 attÄ±k.

.code
mov esi,OFFSET myCount
myCount deÄŸiÅŸkenimizin adresini ESI registerine attÄ±k.

inc [esi] ; bu satÄ±r hata verecektir.
// Peki neden? OFFSET operatÃ¶rÃ¼nÃ¼n, bize adres verdiÄŸinde, iÃ§indeki deÄŸerin boyutunu
// vermediÄŸini sÃ¶ylemiÅŸtik. Bu yÃ¼zden bu komutla, &quot;esi&#x27;nin tuttuÄŸu adresi dereferans
// yapÄ±p iÃ§indeki deÄŸeri bir arttÄ±r&quot; dediÄŸimizi sanÄ±yoruz. Ancak bi sÄ±kÄ±ntÄ± var?
// TuttuÄŸu adresin tipini bilmiyor ki artÄ±rma yapsÄ±n. C&#x27;den de bildiÄŸimiz Ã¼zere
// pointer&#x27;ler deÄŸiÅŸkenin tipi kadar artÄ±rma yapar. Ama biz tipini bilmiyoruz.

inc WORD PTR [esi] ; hata vermez.
// PRT kullanarak ESI&#x27;nÄ±n tuttuÄŸu adresin iÃ§indeki deÄŸeri, WORD tipine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼yoruz.
// Evet artÄ±rma yapacaÄŸÄ±z ama artÄ±k artÄ±rÄ±lacak boyutu biliyoruz.

add [esi],20 ; bu satÄ±r hata verecektir.
// Yine yukarÄ±daki sebepten kaynaklanÄ±yor. Burada toplama iÅŸlemi yapÄ±p ESI&#x27;nin
// gÃ¶sterdiÄŸi adresin deÄŸerine 20 eklemek istiyoruz ama biz ESI&#x27;nin deÄŸerini tipini
// bilmiyoruz. Diyebilirsiniz ki: &quot;Biz zaten yukarÄ±da PTR ile tipini vermiÅŸtik&quot;
// PRT operatÃ¶rÃ¼ sadece bulunduÄŸu komutta iÅŸlenmek Ã¼zere tipini deÄŸiÅŸtirir. KalÄ±cÄ±
// bir deÄŸiÅŸiklik deÄŸildir. Python&#x27;daki, sadece deÄŸiÅŸkeni kullanÄ±rken tipini
// dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ÄŸÃ¼mÃ¼z zamanÄ± dÃ¼ÅŸÃ¼nÃ¼n:
// Yani; deÄŸer = &quot;35&quot;, int(deÄŸer) -&gt; 35 bir string olmasÄ±na raÄŸmen anlÄ±k olarak onu int&#x27;e Ã§evirdik.
// Ama bu asÄ±l deÄŸiÅŸkenin deÄŸerini etkilemeyecektir.

add ax, [esi] ; burada hata vermez
// Diyebiliriz ki hala, ESI&#x27;nÄ±n derefere ettiÄŸi deÄŸerin boyutunu bilmiyoruz. NasÄ±l ekleme
// yapabiliyoruz? AX ve AL register&#x27;leri, burada boyutu belirliyor. ESI&#x27;nin deÄŸerinin
// tipini bilmesek de ax bizim iÃ§in 2 byte olarak toplama yapacaÄŸÄ±mÄ±zÄ± sÃ¶ylÃ¼yor.

add WORD PTR [esi],20 ; hata vermez
// YukarÄ±daki aÃ§Ä±klamalarÄ±n Ä±ÅŸÄ±ÄŸÄ±nda burasÄ± da anlaÅŸÄ±labilir.
// Yani ESI&#x27;nin deÄŸerini tipini PRT sayesinde WORD olarak belirliyor ve belirledikten
// sonra esi&#x27;nin deÄŸerine 20 ekliyor.</code></pre><pre id="a8a7987f-01a8-443e-b46a-9a0ab00a64fc" class="code"><code>Dizi Toplama Ã–rneÄŸi

- Indirect operands&#x27;Ä±n kullanÄ±ldÄ±ÄŸÄ± iyi yerlerden birisi dizi iÅŸlemleridir.

.data
arrayW WORD 1000h,2000h,3000h
// bir dizi oluÅŸturduk

.code
mov esi,OFFSET arrayW
// esi registerine arrayW dizisinin baÅŸlangÄ±Ã§ adresini yani ilk elamanÄ±n adresini attÄ±k

mov ax,[esi]
// esi registerinin derefere ettiÄŸi deÄŸeri(1000h) ax registerine atÄ±yoruz.

add esi,2
// Dizideki her elemanÄ±n boyutu 2 byte(WORD) olduÄŸu iÃ§in ESI&#x27;ye 2 byte eklersek dizinin
// ikinci elemanÄ±nÄ±n adresine ulaÅŸÄ±rÄ±z.
// Bunun diÄŸer bir yÃ¶nttemiyse;
// add esi,TYPE arrayW -&gt; arrayW&#x27;nin ilk deÄŸerinin boyutunu, esi&#x27;ye ekler ve ikinci
// elemanÄ±n adresine ulaÅŸÄ±r.

add ax,[esi]
// ESI&#x27;nÄ±n derefere ettiÄŸi deÄŸeri yain arrayW&#x27;nin ikinci elemanÄ±nÄ±(2000h) ax registerine
// ekliyoruz. AX registerine az Ã¶nce arrayW&#x27;nin ilk elemanÄ±nÄ± atmÄ±ÅŸtÄ±k bÃ¶ylece
// ilk ve ikinci elemanÄ±Ä± toplamÄ±ÅŸ olduk.

add esi,2
// ESI&#x27;deki adrese 2 byte ekleyerek(WORD Ã§Ã¼nkÃ¼) arrayW&#x27;nin Ã¼Ã§Ã¼ncÃ¼ elemanÄ±na vardÄ±k.
// ArtÄ±k ESI&#x27;de arrayW&#x27;nin Ã¼Ã§Ã¼ncÃ¼ elamanÄ±n adresi tutuluyor.

add ax,[esi]
// ESI&#x27;nÄ±n derefere ettiÄŸi deÄŸeri yain arrayW&#x27;nin Ã¼Ã§Ã¼ncÃ¼ elemanÄ±nÄ±(3000h) ax registerine
// ekliyoruz. AX registerine az Ã¶nce arrayW&#x27;nin ikinci elemanÄ±nÄ± da atmÄ±ÅŸ ve 
// dizinin birinci elemanÄ± ile toplamÄ±ÅŸtÄ±k. BÃ¶ylece bun ikisinin toplamÄ±na Ã¼Ã§Ã¼ncÃ¼
// elemanÄ± da eklemiÅŸ olduk. HayÄ±rlÄ± olsun artÄ±k dizimizi toplamÄ±ÅŸ olduk</code></pre><pre id="e02f6698-64f1-44d9-9e8c-dcd180407de2" class="code"><code>OFFSET&#x27;lerin tipi DWORD&#x27;dÃ¼r(4 byte). Yani DWORD tipindeki bir deÄŸiÅŸken OFFSET tutabilir</code></pre><pre id="c71fed27-4d5e-43bc-8b15-438eb014c753" class="code"><code>BaÅŸka bir deÄŸiÅŸkenin OFFSET&#x27;ini tutan bir pointer tanÄ±mlanabilir

.data
arrayW WORD 1000h,2000h,3000h
ptrW DWORD arrayW ;
// ptrW, ÅŸuanda arrayW&#x27;nin OFFSET&#x27;ini yani adresini tutuyor.
// Bu iÅŸlem ayrÄ±ca ÅŸÃ¶yle de yapÄ±labilir ki daha aÃ§Ä±klayÄ±cÄ± gÃ¶zÃ¼kÃ¼yor:
// ptrW DWORD OFFSET arrayW

.code
mov esi,ptrW
// ptrW&#x27;de az Ã¶nce gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ã¼zer arrayW&#x27;nin adresi vardÄ±. Biz bu adresi ESI
// registerine atÄ±yoruz.

mov ax,[esi] ; AX = 1000h
// ESI registerinde olan bu adresin deÄŸeri yani 1000h&#x27;yi ax registerine atÄ±yoruz.</code></pre><pre id="48f3836a-6ce6-440f-9182-54cec206c344" class="code"><code>Indexed Operands

C&#x27;de ve Ã§oÄŸu dildeki gibi dizinin elemanlarÄ±na index yardÄ±mÄ±yla ulaÅŸmaktÄ±r.

Ä°ki Ã§eÅŸit gÃ¶sterimi vardÄ±r:
- [label+register]
- label[register]

.data
arrayW WORD 1000h,2000h,3000h

.code
mov esi,0 -&gt; esi registerindne ÅŸuan 0 var
mov ax,[arrayW + esi] ; AX = 1000h
// ax registerine, arrayW dizisinin ilk elamanÄ±nÄ± atar. Ã‡Ã¼nkÃ¼ dizi zaten bir adrestir
// KÃ¶ÅŸeli paranteez ile referans kÄ±rar ve deÄŸerini alÄ±r. arrayW, ilk elemanÄ±
// gÃ¶stermektedir. ESI yani 0 ekleyince de yine aynÄ± yerinde kalmÄ±ÅŸ olacak yani ilk
// elemanÄ± atayacak.

mov ax,arrayW[esi] ; alternatif format
// &quot;arrayW dizisinin ESI registerindeki deÄŸeri hangi deÄŸerse o dizinin o deÄŸerinci
// elemanÄ±nÄ± seÃ§ diyoruz. ESI&#x27;miz 0 olduÄŸu iÃ§in ilk elemanÄ± seÃ§er. C&#x27;den biliyoruz
// zaten :)

add esi,TYPE arrayW
// arrayW&#x27;nin tipi her elemanÄ±nÄ±n tipi WORD(2 byte). O zaman TYPE operatÃ¶rÃ¼ bize
// 2 deÄŸerini dÃ¶necek ve bunu ESI&#x27;ye atayacaktÄ±r. 

add ax,[arrayW + esi]
// arrayW&#x27;nin adresine ESI&#x27;yi yani 2 deÄŸerini ekler. O da dizini ikinci elemanÄ±nÄ±n
// adresine denk gelir. O adresin deÄŸerini yani ikinci elemanÄ±nÄ± verir.</code></pre><pre id="a9dbd8be-aeee-41d7-a2a5-2fb7d5d61439" class="code"><code>JMP Instruction 

Kodda atlamaya yarar.
Atlamak iÃ§in herhangi bir koÅŸul gerekmez.
DÃ¶ngÃ¼lerde, ÅŸartlarda Ã§okÃ§a kullanÄ±lÄ±r.

Ä°sminin  JMP olmasÄ± bir ÅŸeyi deÄŸiÅŸtirmez. O bizim iÃ§in hala &#x27;goto&#x27; :)

C&#x27;deki goto ile aynÄ± iÅŸlevi gÃ¶rÃ¼r ve sytntax&#x27;larÄ±(yazÄ±mlarÄ±) dahi aynÄ±dÄ±r.

myLabel:
	// burada kodlar var iÅŸte
	// .
	// .
jmp myLabel

ÅÃ¶yle Ã§alÄ±ÅŸÄ±r: Kod &#x27;jmp myLabel&#x27;e geldiÄŸinde myLabel etiketinin olduÄŸu satÄ±ra geri
dÃ¶ner ve orayÄ± tekrar Ã§alÄ±ÅŸtÄ±rÄ±r. EÄŸer bir ÅŸart olmazsa orasÄ± sonsuza kadar Ã§alÄ±ÅŸÄ±r</code></pre><pre id="4b9b634f-792b-41ea-b7ca-4928aea042e3" class="code"><code>LOOP Instruction

Loop(dÃ¶ngÃ¼) yazmaya yarar.

Syntax&#x27;Ä± JMP&#x27;ninkine benzemektedir. Hatta aynÄ±sÄ±dÄ±r.

mov ecx, 5
myLabel:
	// burada kodlar var iÅŸte
	// .
	// .
loop myLabel

Oradaki &#x27;ecx&#x27; ne? ECX bir register tÃ¼rÃ¼. Genellikle dÃ¶ngÃ¼lerdeki iterasyon sayÄ±sÄ±nÄ±
tutar. Ä°ÅŸte tam da burada JMP komutundan ayrÄ±lÄ±yor. JMP, bir koÅŸul olmadÄ±kÃ§a sonsuza
kadar atlardÄ±.
Ancak LOOP komutuna gelip her, myLabel&#x27;e atlama yaptÄ±ÄŸÄ±nda ecx registeri bir azaltÄ±lÄ±r.
ECX 0 olduÄŸunda dÃ¶ngÃ¼ biter.
BÃ¶ylece dÃ¶ngÃ¼ belli sayÄ±da dÃ¶nmÃ¼ÅŸ olur. Biz baÅŸta ecx&#x27;i 5 olarak tanÄ±mladÄ±k.
Loop komutuna geldi, ve sonra myLabel etiketinin olduÄŸu koda sÄ±Ã§radÄ±. Ve tekrar LOOP&#x27;a
geldi. Bu bÃ¶yle devam eder ve her atlayÄ±ÅŸta ecx bir azaldÄ±. ECX 0 olduÄŸunda da dÃ¶ngÃ¼mÃ¼z
sonlandÄ±.
-------------------------------
mov ax,6
mov ecx,4 ;Loop 4 times
L1:
	inc ax
loop L1

// ECX yani LOOP iÃ§in gereken register&#x27;i 4 olarak tanÄ±mladÄ±k yani dÃ¶ngÃ¼ 4 kez dÃ¶necek.
// AX registerini ise 6 olarak belirledik.
// Kod akar. &#x27;inc&#x27; ax&#x27;i gÃ¶rdÃ¼ÄŸÃ¼nde ax registerindeki deÄŸeri yani 6&#x27;yÄ± bir artÄ±rÄ±r.
// Loop komutuna geldiÄŸinde L1 label&#x27;ine(satÄ±rÄ±na) geri dÃ¶ner. Bir aÅŸaÄŸÄ± iner ve ax 
// registerini bir artÄ±rÄ±r ve yine dÃ¶ngÃ¼ye gelip yine L1&#x27;e zÄ±plar ve aynÄ± iÅŸlemi yapar.
// Ne zaman ki eax 0 oldu, iÅŸte o zaman artÄ±k LOOP sÄ±Ã§rama yapamaz ve kod (yazmadÄ±ÄŸÄ±mÄ±z)
// alttaki diÄŸer satÄ±rlardan devam eder.

NOT!! ECX&#x27;in ilk deÄŸeri 0 olamaz. Yani &quot;mov ecx, 0&quot; kodu hata verecektir.</code></pre><pre id="0bd6cade-1811-4f78-87c5-1b8db83f699b" class="code"><code>Ä°Ã§ iÃ§e DÃ¶ngÃ¼

EÄŸer iÃ§ iÃ§e dÃ¶ngÃ¼ yapÄ±lmak isteniyorsa en dÄ±ÅŸarÄ±da tanÄ±mlanan ecx registeri
Ã¶nce bir deÄŸiÅŸkende saklanacak. ECX sadece bir dÃ¶ngÃ¼nÃ¼n iterasyonunu saymak iÃ§in
kullanÄ±labilir. AynÄ± anda iki loop&#x27;u sayamaz. Bu yÃ¼zden dÄ±ÅŸ dÃ¶ngÃ¼nÃ¼n kaÃ§ kere dÃ¶neceÄŸini
kaydettik.
Daha sonra iÃ§teki dÃ¶ngÃ¼ kaÃ§ kez dÃ¶nÃ¼lmesi isteniyorsa ECX&#x27;e o sayÄ± atanacak.
Ä°Ã§teki dÃ¶ngÃ¼ kendi kendini tamalayacak. Daha sonra dÄ±ÅŸ dÃ¶ngÃ¼ dÃ¶nmek iÃ§in 
diÄŸer label&#x27;e gidecek. Gitmeden hemen Ã¶nce count, ECX&#x27;e atanacak. Yani loop&#x27;a girdiÄŸi
anda ECX bir azaltÄ±lmÄ±ÅŸ olacak.
Label&#x27;e girdikten sonra ECX&#x27;i count&#x27;a atayacaÄŸÄ±z. Ã‡Ã¼nkÃ¼ artÄ±k ecx, iÃ§ dÃ¶ngÃ¼ iÃ§in
kullanÄ±lacak.
Åimdi ise iÃ§ dÃ¶ngÃ¼nÃ¼n iterayon sayÄ±sÄ± ECX&#x27;e atanacak ki iÃ§ dÃ¶ngÃ¼ o kadar dÃ¶nsÃ¼n.</code></pre><figure id="b1cdaf21-02ef-4308-85aa-53f1dcdfee33" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_162144.png"><img style="width:672px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-26_162144.png"/></a><figcaption>DÄ±ÅŸ dÃ¶ngÃ¼ (Loop L1)100 kez, iÃ§ dÃ¶ngÃ¼(Loop L2) ise 20 kez dÃ¶necek.</figcaption></figure><pre id="1d5031b0-e41a-466d-8d2f-13e756cab6aa" class="code"><code>DÃ¶ngÃ¼ler ile Dizi Toplama Ä°ÅŸlemi

.data
intarray WORD 100h,200h,300h,400h

.code
mov edi,OFFSET intarray
// intArray dizisinin ilk elemanÄ±nÄ±n adresini edi regsiterine atadÄ±k

mov ecx,LENGTHOF intarray
// DÃ¶ngÃ¼ eleman sayÄ±sÄ± kadar dÃ¶neceÄŸi iÃ§in dizinin eleman sayÄ±snÄ± ecx registerine attÄ±k

mov ax,0
// toplama iÅŸlemimizi ax registeri Ã¼zerinde yapacaÄŸÄ±z ve ilk deÄŸerini 0 olarak atadÄ±k

L1:

add ax,[edi]
// ax registerine edi registerinin gÃ¶sterdiÄŸi adresin deÄŸerini ekliyoruz.

add edi,TYPE intarray
// edi registeri ile dizinin boyutunu(WORD/2 byte) topluyor ki edi registeri bir sonraki
// elamanÄ±n adresini gÃ¶stersin.

loop L1
// ecx, 0 olana kadar dÃ¶ngÄŸ devam eder ve her adÄ±mda ecx 1 azalÄ±r</code></pre><pre id="cf30c42c-2f7f-4e9c-be40-4db3ec029b1a" class="code"><code>String Kopyalama

.data
source BYTE &quot;This is the source string&quot;,0
// Stringin herbir karakterini boyutu 1 byte olduÄŸu iÃ§in byte olarak tanÄ±mlandÄ±.

target BYTE SIZEOF source DUP(0)
// Stringin boyutu kadar bir dizi oluÅŸturulup iÃ§leri &#x27;0&#x27; ile dolduruldu.
// BÃ¶ylece elimizdeki stringi kopyalayacaÄŸÄ±mÄ±z diziyi oluÅŸturduk.

.code
mov esi,0
// esi registerini 0 yaptÄ±k. ESI&#x27;yi index tutucu olarak kullanacaÄŸÄ±z. Ä°lk deÄŸerini 0,
// yani ilk indexin deÄŸerini veriyoruz.

mov ecx,SIZEOF source ; loop counter
// stringimizn boyutunu ecx&#x27;e atayacaÄŸÄ±z ki dÃ¶ngÃ¼, karakter sayÄ±sÄ± kadar dÃ¶nsÃ¼n.

L1:
mov al,source[esi] ; get char from source
// stringin ESI&#x27;ninci elemanÄ±nÄ± &#x27;al&#x27; registerine kopyalar. ESI&#x27;ninci eleman derken ÅŸunu
// kastediyorum. ESI&#x27;nin gÃ¶sterdiÄŸi adresin iÃ§indeki deÄŸer.
 
mov target[esi],al ; store it in the target
// String kopyalamak iÃ§in oluÅŸturduÄŸumuz &#x27;target&#x27; dizisinin ESI&#x27;ninci elemanÄ±na , &#x27;al&#x27;
// registerini kopayalar. &#x27;AL&#x27; registerinde ise ÅŸuanda stringin, ESI&#x27;ninci karakteri
// bulunuyor. 

inc esi
// ESI&#x27;nÄ±n gÃ¶sterdiÄŸi adresi, stringin boyutu kadar(WORD/2 byte) artÄ±rÄ±yor.
// BÃ¶ylece stringin bir sonraki elemanÄ±na yani harfimne gidiyor.
// Ã‡Ã¼nkÃ¼ stringin her karakteri hem bir byte&#x27;dÄ±r hem de aslÄ±nda bir dizinin bir
// elemanÄ±dÄ±r.
// String de bir dizi olduÄŸu iÃ§in index&#x27;ine ulaÅŸabiliyoruz.

loop L1
// String&#x27;deki tÃ¼m karakterler bitip string sonuna gelene kadar dÃ¶ngÃ¼ devam eder ve 
// ecx 0 olur.</code></pre><hr id="efb5126f-f0f6-4f17-b953-de284d83f8d0"/><h2 id="830b7357-39c3-46a7-b66a-a9fde9a21646" class="">Slayt 5 ve 6</h2><hr id="3ddc25b7-b1bf-49aa-88a5-0eef795d3ee4"/><pre id="fe7958b0-7110-4a6b-a7b7-3a91385c430c" class="code"><code>Program makine Ã¼zerinde uygulanÄ±rken algoritma zihin/kaÄŸÄ±t Ã¼zerinde uygulanÄ±r.
Program ve algoritma BU AÃ‡IDAN BAKARSAK aynÄ± ÅŸeydir.

Program, komut setidir.</code></pre><pre id="7ef294bb-effb-4b9e-9fa5-2f085d8d491a" class="code"><code>Random access Memory, istediÄŸimiz herhangi bir adrese aynÄ± sÃ¼rede eriÅŸebildiÄŸimiz iÃ§in
&quot;random access&quot; ismini almÄ±ÅŸtÄ±r.</code></pre><pre id="8bcafb95-c5f0-4613-93c2-7670fe947cdd" class="code"><code>DRAM: dynamic ram -&gt; daha ucuzdur
sram: statik ram -&gt; daha hÄ±zlÄ±dÄ±r

Core: Ä°ÅŸemcinin iÃ§inde bulunur. Ä°Ã§inde ALU, CU ve diÄŸer iÅŸlemci elemanlarÄ± bulunur.
Yani aslÄ±nda core da bir iÅŸlemcidir.</code></pre><pre id="3655f4f3-a831-443b-96ec-587ecb8bc05b" class="code"><code>Ä°ÅŸlemcide 4 core varsa 4 tane cache var demektir. Verilerin dÃ¼zgÃ¼n bir ÅŸekilde kontrol
edilebilmesi iÃ§in cache&#x27;leri kontrol eden bir ÅŸeyin olmasÄ± gerekir.
Bunun iÃ§in DRAM memory controller bulunur.
DRAM(ler) ve cache&#x27;ler arasÄ±ndaki iletiÅŸimleri kontrol eder.</code></pre><pre id="cb238ac0-7f90-415d-9198-65650ff63a57" class="code"><code>Register&#x27;ler bÃ¼yÃ¼rse Ä±sÄ± artar. Bu yÃ¼zden registerler daha fazla bÃ¼yÃ¼tÃ¼lmÃ¼yor.

Register&#x27;lar, kapÄ±lar olduÄŸu iÃ§in hÄ±zlÄ±dÄ±r. Memory&#x27;de kapÄ±lar yoktur ve bu yÃ¼zden yavaÅŸ

Cache&#x27;ler statik ram&#x27;lardÄ±r. Bu yÃ¼zden hÄ±zlÄ±dÄ±r. (Ã§Ã¼nkÃ¼ statik ram dinamik ram&#x27;den hÄ±zlÄ±)

Bizim kullandÄ±ÄŸÄ±mÄ±z RAM&#x27;lar ise dinamik RAM&#x27;lerdir.</code></pre><pre id="bf3d665b-04d6-427a-bec5-21d2b2c1c10f" class="code"><code>Cache yÃ¶netimi Ã§oÄŸunlukla iÅŸletim sistemi ve derleyici tarafÄ±ndan yapÄ±lÄ±r. C ve Matlab
baÅŸta olmak Ã¼zere bunu Ã§oÄŸunlukla derleyiciler yapar.</code></pre><pre id="dfabf88d-6aa1-4def-9966-b662abcc8f9a" class="code"><code>DRAM, kapasitÃ¶rlerden oluÅŸur.
Veriler, kondansator(kapasitor)de depolanÄ±r.
Bir DRAM chip&#x27;i 10 ile 1000 arasÄ± cell(hÃ¼cre) row(satÄ±r)undan oluÅŸur.</code></pre><pre id="dcdb6ed3-d70f-4ade-b30e-616332e4229a" class="code"><code>Memory refresh: Ram&#x27;deki bilgiler sÃ¼rekli yenilenmezse birkaÃ§ milisaniye iÃ§inde kaybolur.
Ã‡Ã¼nkÃ¼ DRAM kapasitÃ¶rÃ¼ veri kaybÄ± yapar.
Bunun iÃ§in memory&#x27;deki bilgileri okuyup hemen tekrar yazmaktÄ±r(yenilemektir).
Her yenileme, enerji harcar.
Yenileme esnasÄ±nda DRAM bank&#x27;a ulaÅŸÄ±lamaz.
Her satÄ±rÄ±n yenilenme sÃ¼resi 64ms gibi bir ÅŸey alÄ±r.

Bu yÃ¼zden(sÃ¼rekli yenilenme olduÄŸu iÃ§in) bizim RAM&#x27;lerin ismi Dinamik RAM&#x27;dir.

Bu iÅŸi iÅŸletim sistemi yapar.

SRAM, ise transistÃ¶rlerde depolanÄ±r. Elektrik kesintisi olmadÄ±ÄŸÄ± iÃ§in veri yenilenmesi
gerekmez.</code></pre><pre id="2cf2e9ce-cce2-413b-a9a3-dfa62257a049" class="code"><code>Bilgisayar Mimarisi: fonksiyonel(functional), performans, enerji tÃ¼ketimi, maliyet ve diÄŸer
belirli hedefleri karÅŸÄ±layan bir bilgi iÅŸlem sistemi oluÅŸturmak iÃ§in donanÄ±m
bileÅŸenlerini tasarlama, seÃ§me ve birbirine baÄŸlama ve donanÄ±m/yazÄ±lÄ±m arabirimini
tasarlama bilimi ve sanatÄ±dÄ±r.

Buradaki fonkiyonellik, devre tasarÄ±mÄ±na baÄŸlÄ±dÄ±r.</code></pre><pre id="004e82a7-6939-4526-9ef3-11943d29b3e1" class="code"><code>Moore yasasÄ±:

Ä°ÅŸlemcilerde nesil arttÄ±kÃ§a transistÃ¶r sayÄ±sÄ± artar</code></pre><figure id="c9696832-264d-4836-b3d1-9c7a8e1efaa5" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_172755.png"><img style="width:708px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_172755.png"/></a></figure><pre id="20a4f1f2-aee9-4449-9272-22b423310f3e" class="code"><code>TasarÄ±mcÄ±lar iÃ§in RISC daha kolaydÄ±r. Kendi iÅŸlerini azaltarak iÅŸleri
kullanÄ±cÄ±ya(programcÄ±ya) bÄ±rakÄ±r.</code></pre><h3 id="f3d112cb-088f-4ad9-8f7f-df69453ca163" class="">Von Neumann ve Control Flow</h3><pre id="738444d3-13a1-4f3a-b955-0fdc873af4c4" class="code"><code>- Komutlar hafÄ±zada lineer bir ÅŸekilde dizilidir.

- Komutlar ve veriler iÃ§in tek bir yol vardÄ±r.

- Bir zamanda(one cycle) sadece bir instruction(fetch/decode/execute) iÅŸlenir.

- Komutun bitip bitmediÄŸini anlamak iÃ§in instruction pointer/ program counter vardÄ±r
	ve bu arkadaÅŸ Ã§alÄ±ÅŸtÄ±rÄ±lmakta olan komuttan bir sonraki komutu gÃ¶sterir.

- Program counter, &quot;control transfer instructions(dÃ¶ngÃ¼ler)&quot; dÄ±ÅŸÄ±nda sÄ±ralÄ± olarak iÅŸler.

- Bir komut bittiÄŸi zaman diÄŸer komutun Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±na geÃ§ilir.


Von Neumann = Control Flow

Von Neumann Control Flow kullandÄ±ÄŸÄ± iÃ§in Control Flow&#x27;un Ã¶zellikleri aslÄ±nda
Von Neumann&#x27;Ä±n sahip olduklarÄ±dÄ±r. Yani yukarÄ±da sayÄ±lan maddeler control flow&#x27;un
Ã¶zellikleridir. Bu yÃ¼zden Control Flow Model&#x27;e Von Neumann Model de denmektedir.

Control Flow =&gt; SÄ±ralÄ± Ã‡alÄ±ÅŸtÄ±rma</code></pre><figure id="13693dc3-1d7b-480c-9949-fbfd307aef3e" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_173747.png"><img style="width:776px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_173747.png"/></a></figure><h3 id="daaec20b-0f4c-408f-b2cd-60b11536ce97" class="">Dataflow Model</h3><pre id="f359c5fb-752b-495e-a455-1dba498eb4d2" class="code"><code>- Herhangi bir programÄ±n iÅŸlemci tarafÄ±ndan Ã§alÄ±ÅŸma ÅŸeklidir.

- Bir komutun(instruction) Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ±n bir Ã¶nceki komuta baÄŸlÄ± olmamasÄ±dÄ±r.

- Bir komut Ã¶nceki komuta baÄŸlÄ±ysa baÄŸlÄ± olan komut paralel olarak gerÃ§ekleÅŸir.

- TÃ¼m operand&#x27;lar hazÄ±r olduÄŸunda komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

- Instruction pointer(program counter) yoktur.

- KomutlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lma sÄ±rasÄ± data flow dependence(flow dependence
	bir graftÄ±r. Program counter olmadÄ±ÄŸÄ± iÃ§in komutlar sÄ±ralÄ± Ã§alÄ±ÅŸtÄ±rÄ±lmaz.
	Flow Dependence&#x27;nin belirlediÄŸi bir sÄ±rada Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r) tarafÄ±ndan belirlenir.

- Bir komutun operandlarÄ±ndan herhangi birisi ya da daha fazlasÄ± baÅŸka bir komuta
	baÄŸlÄ±ysa bu komutlar paralel olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

- Potansiyel olarak tÃ¼m komutlar aynÄ± zamanda Ã§alÄ±ÅŸtÄ±rÄ±labilir. (Paralellism)</code></pre><pre id="82d71257-ddec-49aa-92f5-e01a86e089a6" class="code"><code>Paralel programlama(paralellism) iÃ§in birden fazla iÅŸlemci gerekir, komutlar aynÄ± anda Ã§alÄ±ÅŸÄ±r.

ProgramÄ± thread&#x27;lere de bÃ¶lmekle paralel programlama yapmÄ±ÅŸ olmayÄ±z, komutlar hala sÄ±ralÄ±
Ã§alÄ±ÅŸÄ±r. Sadece aynÄ± zamanda Ã§alÄ±ÅŸÄ±yor gibi gÃ¶zÃ¼kÃ¼r.</code></pre><pre id="64503210-734b-4f36-9ca8-c605c5e351a8" class="code"><code>Data flow makinesinde programlar &quot;data flow node&#x27;larÄ±&quot;ndan oluÅŸur.

Bir data flow node&#x27;u, tÃ¼m inputlar(gerekli veri ve operandlar) hazÄ±r olduÄŸunda
Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r</code></pre><figure id="0af0b34c-95c5-4d42-9609-a7546c861e61" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_193554.png"><img style="width:672px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_193554.png"/></a><figcaption>Muhtemelen ÅŸekil Ã¶nemli deÄŸil ama bi gÃ¶rmÃ¼ÅŸ olalÄ±m</figcaption></figure><figure id="81848301-9035-464d-9262-9c1b3bec48bf" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_193649.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_193649.png"/></a><figcaption>Muhtemelen ÅŸekil Ã¶nemli deÄŸil ama bi gÃ¶rmÃ¼ÅŸ olalÄ±m</figcaption></figure><figure id="1e81e6d7-51c5-4f52-bcb1-f0cdea8272bc" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_185838.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-22_185838.png"/></a><figcaption>Bu Ã¶nemli</figcaption></figure><pre id="0bd6194c-899b-4a52-a1db-789b2aa93e11" class="code"><code>Debug iÅŸlemi, control flow&#x27;da daha kolaydÄ±r.
Control flow daha ucuzdur. Bu yÃ¼zden bizim bilgisayarlar control flow&#x27;dur.</code></pre><pre id="87c37f5b-ef86-4564-a2f0-60995b35be48" class="code"><code>tradeoff: arayÄ± bulmak, dengelemek

Bir kavram ya da Ã¶zellik bir ÅŸeyler getirirken gÃ¶tÃ¼rÃ¼sÃ¼ olacaktÄ±r.</code></pre><pre id="fb1831d8-3710-472c-a903-caeee5dc5ee3" class="code"><code>Program Counter(Instruction Pointer) bir register tipidir. GÃ¶sterim ÅŸekli IP&#x27;dir.
Control flow modelde Ã§alÄ±ÅŸmakta olan instruction&#x27;Ä±n adresini tutar.
Paralel programlamada kullanÄ±lmaz.
Data flow&#x27;da deÄŸerler ve operandlar hazÄ±r olduÄŸu anda komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu yÃ¼zden 
program counter&#x27;a ihtiyaÃ§ yoktur.

Program Counter Trade-off(Benim yorumum):
Program counter&#x27;Ä±n getirileri yukarÄ±da yazÄ±yor.
Ancak program counter geldiÄŸinde paralel programlama ortadan kalkÄ±yor. Bu da
onun gÃ¶tÃ¼rÃ¼sÃ¼ oluyor.</code></pre><pre id="4dd6e5a0-4423-440c-b70e-f76366997df5" class="code"><code>Data Flow vs Control Flow Trade-offs

Derleme iÅŸlemi Control Flow&#x27;da daha kolaydÄ±r.
Data flow daha performanslÄ±dÄ±r Ã§Ã¼nkÃ¼ paralelizm var.
Data flow&#x27;un sahip olduÄŸu donanÄ±mÄ± daha komplekstir. (Neden olduÄŸu malum :) )

// HocanÄ±n yazdÄ±ÄŸÄ± bir iki kelimelik anahtar kelimelerden Ã§Ä±kardÄ±ÄŸÄ±m yorumlar bunlar
// Kesin bilgi deÄŸiller</code></pre><pre id="6025862b-5736-4703-8c0a-ffd91e624706" class="code"><code>Von Neumann ve Data Flow sadece modeldir.

BÃ¼tÃ¼n bÃ¼yÃ¼k &#x27;Instruction Set Artchitectures(ISA)&#x27; Von Neumann modelini kullanmaktadÄ±r.
x86, ARM, MIPS, SPARC, Alpha, POWER
// Buna bizim bilgisayarlarÄ±mÄ±z da dahil.</code></pre><h3 id="8fb3b177-c5cf-4bfa-bcdb-441d6a69323e" class=""><strong>ISA(Instruction Set Artchitecture) vs Microarchitecture</strong></h3><pre id="3844eddc-8961-41cc-b24d-56c378c744ff" class="code"><code>Microarchitecture kelimesi iÃ§in kÄ±saltma olarak &#x27;MA&#x27; kullanacaÄŸÄ±m.

ISA:

ISA, software ile hardware arasÄ±ndaki anlaÅŸmadÄ±r/arayÃ¼zdÃ¼r.
Sistem/kullanÄ±cÄ± programlarÄ±nÄ± yazmak ve hatalarÄ±nÄ± ayÄ±klamak ve kullanÄ±cÄ±ya sÄ±ralÄ± bir
kontrol akÄ±ÅŸÄ± veya bir veri akÄ±ÅŸÄ± yÃ¼rÃ¼tme sÄ±rasÄ± belirtmek iÃ§in programcÄ±nÄ±n
bilmesi gerekenler.

KullanÄ±cÄ±/programcÄ±nÄ±n bu bilgileri gÃ¶rebilmesi ve bilmesi gerekir ve ISA bunlarÄ± saÄŸlar:

- Instructions -&gt; Opcodes, Addressing Modes, Data Types, Instruction Types and Formats,
								Registers, Condition Codes

- Memory -&gt; Address space, Addressability, Alignment, Virtual memory management

- Call, Interrupt/Exception Handling
- Access Control, Priority/Privilege
- I/O: memory-mapped vs. instr.
- Task/thread Management
- Power and Thermal Management
- Multi-threading support, Multiprocessor support

ISA bize yukarÄ±daki bilgileri saÄŸlar.

MA:
MA, ISA&#x27;nÄ±n spesifik bir implementasyonudur. KullanÄ±cÄ±ya/programcÄ±ya gerekli olmayan,
sadece donanÄ±mÄ±n kendisini ilgilendiren iÅŸlemleri iÃ§erir, bunlarÄ± kullanÄ±cÄ± gÃ¶remez:
- Pipelined instruction execution: Intel 80486 uarch
- Multiple instructions at a time: Intel Pentium uarch
- Out-of-order execution: Intel Pentium Pro uarch
- Separate instruction and data caches

// ISA ve MA tam olarak ne saÄŸlardÄ± diye maddeleri ezberlemeye gerek yok.
// Bir programcÄ±nÄ±n bu bilgiye ihtiyacÄ± olur mu?/kullanÄ±r mÄ±? diye kendimize sorup
// cevabÄ± vermemiz yeterli olacaktÄ±r?

Bir ISA, birden fazla MA kullanabilir daha doÄŸrusu birden fazla implementasyonu olabilir:
x86 ISA has many implementations: 286, 386, 486, Pentium, 
                                  Pentium Pro, Pentium 4, Core, ...


â€œArchitecture â€ = ISA + microarchitecture

!!! Microarchitecture, &quot;uarch&quot; olarak adlandÄ±rÄ±lÄ±r.</code></pre><hr id="bf6bf416-eefb-4781-a4ac-679370673acd"/><hr id="fd8f8f42-1d1e-4e0b-b34d-3f8f5ea794fd"/><h2 id="49150ebc-c543-4f64-8ee6-d6530f3799bf" class="">Hafta 7</h2><pre id="6960109a-fe59-4132-b1a0-254eb8b902c3" class="code"><code>VAX iÅŸlemcisi gÃ¶mÃ¼lÃ¼ sistemlerde yaygÄ±n kullanÄ±lÄ±r. FarklÄ± bir mimariye sahiptir.</code></pre><pre id="1aee9bac-9544-4122-87ed-d8774bb182ba" class="code"><code>Instruction? (Talimat/komut)

Instruction ÅŸunlardan oluÅŸur:

- Opcode: instruction ne yapacak (mnemonic = opcode)(Ã¶r: mov, add, sub...)
- operand: operand kim ile iÅŸi yapacak? (Opcode&#x27;un alacaÄŸÄ± deÄŸiÅŸkenler, deÄŸerler...)</code></pre><pre id="7bdd1de0-1765-40d6-b2d7-af525ec30c20" class="code"><code>Her clock&#x27;ta memory&#x27;e sadece bir kez eriÅŸim olduÄŸu iÃ§in aynÄ± atama iÅŸlemi iÃ§inde
iki operand memory olamaz.</code></pre><pre id="905b4255-d221-4270-aea2-7c50b0f18d8f" class="code"><code>makine kodu komutlardan baÅŸlar(.code&#x27;dan baÅŸlar)
Denk geldiÄŸi instruction&#x27;da ihtiyacÄ± olan deÄŸiÅŸkeni gidip .data&#x27;dan getirir.</code></pre><pre id="5aad3a80-cc7f-4b9b-bb04-e546a2068209" class="code"><code>Her instruction&#x27;a, makine koduna derlenirken bir deÄŸer atanÄ±r.
Ama biz bunu belirleyemeyiz. Bu deÄŸeri bilgisayar kendisi atar.
Mesela;
mov ax, 12 ; bilgisayar bu komutu bellekte belki de &#x27;A2&#x27; diye tuttu bilemeyiz.
Her komut benzersiz bir isme sahiptir.</code></pre><h3 id="5321fb12-81bf-4a6e-a781-521de95bb1b8" class=""><mark class="highlight-pink">CISC &amp; RISC KarÅŸÄ±laÅŸtÄ±rma ve AÃ§Ä±klamalar</mark></h3><pre id="89722b1e-5457-4dd7-b68c-b3c6d072c8ac" class="code"><code>RISC&#x27;te her komut en fazla 3 operand alabilir.
CISC&#x27;te her komut en fazla 2 operand alabilir.

OperandÄ±n fazla olmasÄ±yla program daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r.
Ã‡Ã¼nkÃ¼ register fazla olduÄŸundan fetch iÅŸlemi tekrar yapÄ±lmaz.
Register&#x27;lar memory&#x27;den hÄ±zlÄ± olduÄŸu her komut iÃ§in memory&#x27;e gitmek yerine
tek komutta iÅŸlem yapar.

CISC&#x27;te daha fazla talimat(instruction) olur. Bu yÃ¼zden daha fazla execute yapÄ±lÄ±r.
Bu yÃ¼zden hÄ±zÄ± azalÄ±r.

RISC daha hÄ±zlÄ±dÄ±r Ã§Ã¼nkÃ¼ CISC&#x27;in devresi karmaÅŸÄ±ktÄ±r. KarmaÅŸÄ±k olmasÄ± yavaÅŸlÄ±ÄŸÄ± getirir.

RISC&#x27;te daha az veri tipi vardÄ±r.
CISC&#x27;te daha fazla veri tipi olmasÄ± programcÄ±nÄ±n iÅŸini kolaylaÅŸtÄ±rÄ±r.
Ancak veri tipinin fazlalÄ±ÄŸÄ±, iÅŸlemcideki devre sayÄ±sÄ±nÄ± artÄ±racaÄŸÄ±ndan iÅŸlemciyi
karmaÅŸÄ±k hale getirir.

Semantic Gap: ProgramcÄ±nÄ±n yazdÄ±ÄŸÄ± diller ile mikroiÅŸlemcilerin makine dili arasÄ±ndaki fark.
Yaaaani:);
ProgramcÄ± kodlama yaparken donanÄ±m programcÄ±yÄ± ne kadar kÄ±sÄ±tlÄ±yorsa ya da 
ilgilendiriyorsa semantic gap o kadar fazladÄ±r.
Bu yÃ¼zden yÃ¼ksek seviyeli programlama dillerine yaklaÅŸtÄ±kÃ§a semantic gap azalÄ±r. Ã‡Ã¼nkÃ¼
yÃ¼ksek seviyeli dillere Ã§Ä±ktÄ±kÃ§a donanÄ±mdan soyutlanamaya baÅŸlarÄ±z.
BilgisayarÄ±n diline indikÃ§e de semantic gap artar Ã§Ã¼nkÃ¼ gittikÃ§e donanÄ±mÄ±n yapÄ±sÄ±yla
ilgilenmeye baÅŸlarÄ±z.
Semantic gap arttÄ±kÃ§a programcÄ±nÄ±n iÅŸi zorlaÅŸÄ±r ancak tasarÄ±mcÄ±nÄ±n iÅŸi kolaylaÅŸÄ±r.

RISC, Little Endian(Bir byte&#x27;dan bÃ¼yÃ¼k verilerin ters sÄ±rayla hafÄ±zaya kaydedilmesi)
ÅŸekilde memory&#x27;de kaydedilir.
CISC, Big Endian(verilerin dÃ¼z sÄ±rayla hafÄ±zaya kaydedilmesi) ÅŸekilde memory&#x27;de kaydedilir.

Kaydedici(register) sayÄ±sÄ± ne kadar artarsa hÄ±z artar. DeÄŸerleri memory yerine
kaydedicilerde depolarsak, daha az fetch iÅŸlemi olacaktÄ±r. Bu da daha az memory&#x27;e gitmek
demektir. Register, memory&#x27;den daha hÄ±zlÄ± ve iÅŸlemcinin iÃ§inde olduÄŸu iÃ§in hÄ±z kazandÄ±rÄ±r

Register&#x27;lerdeki bit sayÄ±sÄ± artarsa hÄ±z artar.
Ã‡Ã¼nkÃ¼ Daha bÃ¼yÃ¼k sayÄ±larla iÅŸlem yapÄ±labilir.
// AÅŸaÄŸÄ±daki Benim Yorumum
- Ã‡ok bÃ¼yÃ¼k bir iÅŸlemi daha az bitle birkaÃ§ adÄ±mda yapmak var.
- Bir de tek adÄ±mda iÅŸlem yapmak var. Bu yÃ¼zden hÄ±z artar.

Adressing Modes(DÃ¶kÃ¼manÄ±n baÅŸlarÄ±ndaki addressing modes akla gelsin): 
RISC; Load/Store Architecture kullanmaktadÄ±r. Load/Store Architecture&#x27;ye gÃ¶re;
aritmetiksel ve mantÄ±ksal iÅŸlemler SADECE kaydedicilerde yapÄ±labilir.
Memory&#x27;deki bir deÄŸerin register&#x27;e kopyalanmasÄ±na LOAD, register&#x27;deki bir deÄŸerin
hafÄ±zaya kopyalanmasÄ±na ise STORE denir.

CISC; Memory architecture kullanmaktadÄ±r. Memory Architecture&#x27;ye gÃ¶re;
aritmetiksel ve mantÄ±ksal iÅŸlemler de dahil olmak Ã¼zere iÅŸlemler register ve AYRICA
MEMORY&#x27;de de yapÄ±labilir. Ancak iki operand birden memory olamaz. Ã‡Ã¼nkÃ¼ 
bu mimaride tek clock&#x27;ta sadece bir komut yÃ¼rÃ¼tÃ¼lebiliyor. EÄŸer iki operand da memory
olursa tek clock&#x27;ta iki fetch iÅŸlemi olacak ki bu ÅŸuanlÄ±k CISC&#x27;te mÃ¼mkÃ¼n deÄŸil.

Daha fazla addressing mode olmasÄ± programcÄ±nÄ±n iÅŸini kolaylaÅŸtÄ±rÄ±r.
Ancak derleyicinin(compiler) iÅŸini zorlaÅŸtÄ±rÄ±r.
Microarchitecture&#x27;ye daha fazla yÃ¼k bindirir.

Instruction Length:

- RISC&#x27;te tÃ¼m instruction&#x27;larÄ±n boyutlarÄ± eÅŸittir(Fixed Length)
- DonanÄ±mÄ±n her komutu decode etmesi daha kolaydÄ±r. Ã‡Ã¼nkÃ¼ komutlarÄ±n boyutlarÄ± eÅŸittir.
	Yani; bu opcode, operand nerede baÅŸlÄ±yor nerede bitiyor?&#x27;u bulmak iÃ§in efor harcamayacak.
- Ancak bit israfÄ± vardÄ±r. Ã‡Ã¼nkÃ¼ her instruction&#x27;un boyutunu 4 byte&#x27;a sabitlediyse
	2 byte boyutuna sahip instruction&#x27;larÄ±n kalan 2 byte&#x27;Ä± israf olacak.

- CISC&#x27;te instruction&#x27;larÄ±n boyutu deÄŸiÅŸkendir(Variable Length)
	Yani komutun boyutuna gÃ¶re bellekte yer ayrÄ±lÄ±r.
	Bu yÃ¼zden Fixed length&#x27;teki gibi bit israfÄ± olmaz. HafÄ±zayÄ± verimli kullanÄ±r.
	Bu nedenle de Instruction&#x27;un encoding(komutun makine diline Ã§evrimi)safhasÄ±, daha az bit
	olduÄŸu iÃ§in daha kompakttÄ±r.
- KomutlarÄ±n boyutlarÄ± farklÄ± olduÄŸundan her komutun boyutunu ve tipini anlamasÄ± iÃ§in
	efor harcar. Bu yÃ¼zden decode(bilgisayarÄ±n komutu okumasÄ±) safhasÄ±nda daha fazla
	logic(karar aÅŸamasÄ±) vardÄ±r.
- Sonda sayÄ±lan nedenden dolayÄ± devresi daha karmaÅŸÄ±ktÄ±r
- Bu sayÄ±lanlardan sonra trade-off&#x27;larÄ± rahatlÄ±kla Ã§Ä±karÄ±labilir.

AÅŸaÄŸÄ±da (anti parantez) Fixed Length isntruction ile ilgili bir gÃ¶rsel var.
GÃ¶rselden sonra aÃ§Ä±klamalara devam ediyoruz.</code></pre><figure id="5a53f441-c8f0-4c53-866c-e43f258ca7f7" class="image"><a href="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_010030.png"><img style="width:720px" src="Bilgisayar%20mimarisi%203dae22fac8914ed79b38fe8c1f05b6fb/Ekran_grnts_2021-11-23_010030.png"/></a><figcaption>Fixed length instruction: Ã–rneÄŸin RTI komutu hiÃ§ operand almamasÄ±na raÄŸmen aynÄ± boyutu kaplÄ±yor. <em><strong>Ä°SRAF</strong></em></figcaption></figure><pre id="3e7a596b-606a-4f23-91cc-d980d7a366e8" class="code"><code>Uniform Decode(RISC): Her instruction&#x27;daki her bit aynÄ± anlama gelir.
- Instruction&#x27;Ä±n opcode&#x27;unu bulmak Ã§ok kolaydÄ±r Ã§Ã¼nkÃ¼ opcode&#x27;lar hep aynÄ± konumdadÄ±r.
- Opcode ne olursa olsun hepsinin boyutu aynÄ± olduÄŸu iÃ§in komutlarÄ± daha hÄ±zlÄ± bir
ÅŸekilde ayrÄ±ÅŸtÄ±rabilir(decode).
- Opcode&#x27;lar aynÄ± olduÄŸundan daha basit bir donanÄ±mla iÅŸler halledilebilir.
- Her opcode&#x27;un boyutunu aynÄ± olmaya zorladÄ±ÄŸÄ± iÃ§in hafÄ±za israfÄ± yapmaktadÄ±r.

Non-Uniform Decode(CISC):
Opcode&#x27;lar 1 ve 7 byte arasÄ±nda boyut alabilir. Yani her opcode sabit boyuta sahip
deÄŸildir.
Komutu decode etmek zordur Ã§Ã¼nkÃ¼ opcode&#x27;larÄ±n yerlerini tespit etmek ekstra logic
gerektirir.

Aligned Access:
ALIGN opcode&#x27;u bellekte yer ayÄ±rmaya yarar.
CISC&#x27;te align iÅŸlemi yapÄ±lmaz, komut neyse belleÄŸe aynen o ÅŸekilde kaydedilir.

RISC, align yapar. Sadece Ã§ift adreslere veri yazabilme yapabildiÄŸinden(Ã§Ã¼nkÃ¼
tek adrese yazma devresi yok) komutlarÄ± sÄ±rayla yazsak da hafÄ±zaya o ÅŸekilde
kaydedilmeyecek ve sÄ±kÄ±ntÄ±lar Ã§Ä±kacaktÄ±r.
Ancak adresin tek sayÄ±ya dÃ¼ÅŸtÃ¼ÄŸÃ¼ yerlerde ALIGN ile boÅŸ adres ekleyerek sÄ±radaki
komutun Ã§ift adresten devam etmesini saÄŸlÄ±yoruz.


&quot;Åu iÅŸ ÅŸu mimaride yapÄ±lmÄ±yor&quot; dendiÄŸi zaman ya bu iÅŸi yapacak devre mevcut deÄŸildir
ya da iÅŸin olmasÄ± baÅŸka bir sebebin mevcudiyetine baÄŸlÄ±dÄ±r.

YukarÄ±daki Ã§Ä±karÄ±mlardan Ã§Ä±karÄ±mla CISC daha karmaÅŸÄ±k bir komut setidir.

GÃ¼ncelleme iÅŸlemi RISC&#x27;te basittir. Ã‡Ã¼nkÃ¼ devre basittir.
CISC&#x27;te ise devre karmaÅŸÄ±k olduÄŸu iÃ§in gÃ¼ncelleme zordur. O iÅŸlem baÅŸka iÅŸlemlere de baÄŸlÄ±dÄ±r.
Bir gÃ¼ncelleme iÅŸlemi iÃ§in baÅŸka ÅŸeylerde de deÄŸiÅŸiklik yapmak gerekir.

Bizim yeni bilgisayarlarÄ±mÄ±z RISC + CISC yani hibrittir.

RISC sistemlerin Ã§oÄŸu Data Flow Modeline sahiptir.

CISC sistemlerin Ã§oÄŸu Control Flow modeline sahiptir.

RISC daha az maliyet Ã§Ä±karÄ±r(hafÄ±za, iÅŸlemci).

Ã–ZETLE;

RISC:
- Daha basit instruction&#x27;lar
- Fixed length instruction
- Uniform decode
- Daha az adresleme modu

CISC:
- Daha kompleks instruction&#x27;lar
- Variable length instruction
- Non-uniform decode
- Daha fazla adresleme modu

CISC&#x27;e Ã¶rnek olarak bizim bilgisayarlarÄ±mÄ±z.
RISC&#x27;e Ã¶rnek olarak ise ARM iÅŸlemciler yani telefonlarÄ±mÄ±z. Ancak ARM iÅŸlemci daha
geliÅŸmiÅŸ</code></pre><hr id="c4b97314-6e4e-4ba1-ae1b-157790f61333"/><h2 id="d4d3fbc2-047a-4f63-a7ed-58bec0bc70af" class="">Hafta 8</h2><pre id="e3a9b84b-1ad5-4857-8583-a13d21e1cbf4" class="code"><code>Her komut ya single-cycle ya da multi-cycle olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.</code></pre><pre id="77993f68-fec5-4ce4-9931-592b787a1ef6" class="code"><code>Single Cycle: 
Fetch-decode-execute dÃ¶ngÃ¼sÃ¼nÃ¼n tek clock&#x27;ta yapÄ±lmasÄ±.
Bu yÃ¼zden uzun sÃ¼rer.
Single-cycle&#x27;da pipeline dÃ¼zgÃ¼n Ã§alÄ±ÅŸmaz.</code></pre><pre id="c9cd6a63-d819-48bc-a338-0774fe85b64b" class="code"><code>Multi-cycle:
Fetc-decode-execute dÃ¶nÃ¼sÃ¼ndeki her bir adÄ±m bir clock&#x27;ta gerÃ§ekleÅŸir.
KomutlarÄ±n boyutlarÄ± farklÄ± olduÄŸu iÃ§in komutlarÄ±n cevap sÃ¼releri de farklÄ± olur.</code></pre><pre id="16eb7b31-c94d-477e-a85e-d41df7b26bf8" class="code"><code>Single-cycle&#x27;da komutun iÅŸlendiÄŸini gÃ¶steren bir adet flag tutulur. EÄŸer komut iÅŸlenmesi
bittiyse flag 1 olur ve diÄŸer komuta geÃ§ilebilir.

Ama multi-cycle&#x27;da birden Ã§ok flag vardÄ±r. Ã‡Ã¼nkÃ¼ komutlar farklÄ± zamanlarda iÅŸlenir.
FarklÄ± komutlar farklÄ± zamanlarda tamamlanabilir.</code></pre><h3 id="8994a9f4-ef8d-404a-ac73-5f536ab75f2e" class="">Komutun iÅŸlemcide iÅŸlenme sÃ¼reci</h3><pre id="b0b151c3-9d77-4e6f-9157-ba982c4205a6" class="code"><code>Kodun program counter&#x27;inin tutulduÄŸu register&#x27;dan adres yoluna bu adres yazÄ±lÄ±r ve RAM&#x27;e
gider. Ram gelen adrese gÃ¶re uygun komutu veri yolundan gÃ¶nderir.
Gelen veri yani komut CU&#x27;da decode edilir. EÄŸer komutun iÃ§inde bir memory yani deÄŸiÅŸken
varsa bunlarÄ±n adresi farklÄ± register&#x27;lere yazÄ±lÄ±r. Register&#x27;daki adres, adres yolundan
memory&#x27;e giderek memory&#x27;den doÄŸru deÄŸiÅŸken verisini veri yolu Ã¼zerinden getirir.
Gelen deÄŸiÅŸkenler Register&#x27;lerde tutulur. Ancak komutun operandlarÄ±ndan biri Immediate
ise veriyi Ã§ekmek iÃ§in doÄŸal olarak memory&#x27;e gitmez. Immediate, iÅŸlemcide iÅŸlenmek
Ã¼zere bekler.
HafÄ±zadan gelip register&#x27;e atÄ±lan deÄŸiÅŸkenler ve (varsa) immediate, Multiplexer&#x27;e gider.
Multiplexer, her iki operandÄ±n register olup olmadÄ±ÄŸÄ±na bakar. EÄŸer operandlardan
birisi immediate ise ALU ona gÃ¶re ayaklarÄ±ndan birisi ona gÃ¶re ayarlanÄ±r. Ã‡Ã¼nkÃ¼
ALU&#x27;ya sadece iki deÄŸer girebilir.
KÄ±sacasÄ± gelen deÄŸerler ALU&#x27;ya girer ve hesaplama yapÄ±lÄ±r. Daha sonra hesaplanan
deÄŸer ALU&#x27;dan Ã§Ä±kp bir register&#x27;e atÄ±lÄ±r. Ve komut iÅŸlenmesi bitti.
Ama program counter&#x27;in ÅŸuanda artÄ±rÄ±lmasÄ± lazÄ±m diÄŸer komutun adresini tutmak iÃ§in.
ALU, program counter&#x27;in tutulduÄŸu register&#x27;i alÄ±r ve az Ã¶nce iÅŸlediÄŸi komutun 
boyutu kadar deÄŸerini artÄ±rÄ±r ve tekrar gidip aynÄ± registere bunu yazar. BÃ¶ylece
program counter artmÄ±ÅŸ olur.</code></pre><pre id="5d60daf6-c5c8-41f7-b770-b327f5396af7" class="code"><code>Veri yolu ve adres yolu dendiÄŸine bakmayÄ±n. AslÄ±nda ikisi de veri yolu Ã¼zerinden gider.
Veri yolu ve adres yolu tek bir yol Ã¼zerinden gider.
Bu yÃ¼zden bir komutun deÄŸiÅŸkenleri getirilirken diÄŸer komut memory&#x27;den Ã§ekilemez Ã§Ã¼nkÃ¼
veri yolu doldudur. Bu da Von Neumann mimarisinin dezavantajÄ±dÄ±r. Bu bekleme sÃ¼resine
wait state denir.</code></pre><pre id="c40d1dd0-0838-45b9-abb8-5eacdf0e3a4a" class="code"><code>Ä°ÅŸlemcide ya register tipi ya da Immediate tipi vardÄ±r. ALU&#x27;nun giriÅŸlerinden
biri Register olmak zorundadÄ±r. EÄŸer gelen komutta bir register veya bir Immediate varsa
ALU&#x27;nun giriÅŸlerinden biri Immediate olur. Memory diye bir ihtimal yok Ã§Ã¼nkÃ¼ hesaplama
iÃ§in iÅŸlemciye gelen memory&#x27;ler de register&#x27;lere atÄ±lÄ±r.
Gelen komutun ikisi de register mi yoksa biri Ä°mmediate mi diye Multiplexer(seÃ§ici)
bakar. Ona gÃ¶re ALU&#x27;ya gÃ¶nderir.</code></pre><h2 id="76f5c11a-b02c-4fe6-bc44-c2e114684637" class="">Hafta 9</h2><hr id="90ac9571-200d-4a27-a4ba-90e8aa0a6cb8"/><pre id="f54722ce-9d71-4cca-8be8-518444e9851b" class="code"><code>Instruction memory&#x27;e eriÅŸim hakkÄ±mÄ±z yok. Data kÄ±smÄ±nda deÄŸiÅŸkenlerin deÄŸerini
deÄŸiÅŸtirebilmemize raÄŸmen komutlarÄ± elle deÄŸiÅŸtiremeyiz.</code></pre><pre id="5d32ca24-129f-4cfc-ac83-f2ae05bb134f" class="code"><code>Cotrol Flow&#x27;da unconditional jump ve conditional jump vardÄ±r.</code></pre><pre id="de0e74a9-d78c-4932-b3b7-79d39cc6b526" class="code"><code>JMP&#x27;nin operandÄ± ya adrestir ya da registerdir. Yani registerin iÃ§indeki adrestir.</code></pre><pre id="9acc25f2-0860-4a43-bfb0-1cdf1f9e64df" class="code"><code>Tek komut yazÄ±lacaksa if&#x27;e sÃ¼slÃ¼ parantez konmaz Ã§Ã¼nkÃ¼ zaten sÃ¼slÃ¼ parantez
olmayÄ±nca if, false olursa prograam counteri sadece (inst size*2) artÄ±racaÄŸÄ±nÄ± biliyor.
Ancak konmazsa kaÃ§ artÄ±racaÄŸÄ±nÄ± bilemez.</code></pre><h3 id="0a4e6597-62af-4ba8-b01a-8715ed990443" class="">Bellekler</h3><pre id="aa86f7c3-c51e-4d02-8748-85c0e4f81328" class="code"><code>Bellek TÃ¼rleri

Internal (primary) location: Main memory, cache
External (secondary) location: Hard disk, cd...
Procecssor location: register
EEPROM(elektriksel silinebilir programlanabilir salt okunur hafÄ±za): Flash disk, SSD... </code></pre><pre id="9340b937-e291-4ec5-9843-c0bb3b2f3a79" class="code"><code>DeÄŸiÅŸken tipi olarak WORD, 2 byte&#x27;dÄ±r.Memory&#x27;deki WORD farklÄ±dÄ±r. 20 byte da olabilir.
Memory&#x27;deki her satÄ±r bir WORD&#x27;dÃ¼r. Bu yÃ¼zden memory&#x27;yi yapanlar bunu bilebilir,
bakÄ±larak anlaÅŸÄ±lmaz. 
Her satÄ±rdaki bit sayÄ±sÄ±, number of words olarak isimlendirilir.
</code></pre><pre id="fd96a2c0-9a03-4912-97c3-cd6ced523c9c" class="code"><code>Block: Birden fazla satÄ±rÄ±n birleÅŸtiÄŸi yapÄ±dÄ±r.</code></pre><pre id="00583bf3-32ea-414a-add9-60fbb205df4c" class="code"><code>Access Methods

Sequential: Bilgi, diskte sÄ±ralÄ± aranÄ±r. BaÅŸtan sona doÄŸru
Direct access(semi random): Hard disk
Random: Main memory
Associative(karÅŸÄ±laÅŸtÄ±rÄ±cÄ±): Cache</code></pre><pre id="76924340-7d6e-44b0-b9ab-b9aba035bc85" class="code"><code>2Â¹â° byte bir memory&#x27;nin decoderinde 1024 tane AND kapÄ±sÄ± vardÄ±r. Ã‡ok fazla Ä±sÄ±nma olduÄŸu
iÃ§in ve baÅŸka nedenlerden dolayÄ± 2 decodere ayrÄ±lmÄ±ÅŸtÄ±r. 5 tane bit bir decodere, 5 tane
bit baÅŸka decodere gider. BÃ¶ylece her decoderde 2âµ=32 AND kapÄ±sÄ± olur.
1024 neredeeeee? 32 nerede?</code></pre><pre id="588398f7-3778-4a25-a882-380f8c537991" class="code"><code>Blok boyutlarÄ± deÄŸiÅŸken olabilir.</code></pre><pre id="bef2e1b8-a565-4527-946c-b0478e6669d9" class="code"><code>Main memory = 1MB (2 Ã¼ssÃ¼ 20)
Blok boyutu = 64KB (2 Ã¼ssÃ¼ 16)
Memory&#x27;deki blok sayÄ±ssÄ± nedir?

2 Ã¼ssÃ¼ 20 / 2 Ã¼ssÃ¼ 16 = 2 Ã¼ssÃ¼ 4 blok vardÄ±r</code></pre><p id="dd56ce49-1934-4902-a630-0c361480cef2" class="">
</p></div></article></body></html>